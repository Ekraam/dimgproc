// Homework 1// This code performs histogram equalization using the cumulative probability method// Question 2.a.method B and 2.b.method B// This code takes 6 arguments in the following format// program_name input_image.raw output_image_methodA.raw [BytesPerPixel = 1] [Width = 256] [Height = 256]// //// Name: Ekraam Sabir // USC ID: 1428-2892-90// email: esabir@usc.edu// #include <stdio.h>#include <iostream>#include <stdlib.h>#include <math.h>#include <vector>using namespace std;//using std::vector;int main(int argc, char *argv[]){	// Define file pointer and variables	FILE *file;	int BytesPerPixel;	int Height = 256;	int Width = 256;		// Check for proper syntax	if (argc < 5){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout << "This program performs Histogram equalization using the cumulative probability function" << endl;		cout << "You must have 6 arguments in the following format" << endl;		cout << "program_name input_image.raw output_image_methodB.raw [BytesPerPixel = 1] [Width = 256] [Height = 256]" << endl;		return 0;	}	//Get the command line parameters in the appropriate variables	else{	  BytesPerPixel = atoi(argv[3]);	  Width = atoi(argv[4]);	  Height = atoi(argv[5]);	}			// Allocate image data array	unsigned char Imagedata[Height][Width][BytesPerPixel];	// Read image (filename specified by first argument) into image data matrix	if (!(file=fopen(argv[1],"rb"))) {		cout << "Cannot open file: " << argv[1] <<endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), Height*Width*BytesPerPixel, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////		//create a blank new image array	unsigned char newImage[Height][Width][BytesPerPixel];	int inputHistogram[256][BytesPerPixel];	int totalPixels = Height*Width;	vector<vector<vector<int> > > pixelArrangement;	pixelArrangement.resize(totalPixels);	for (int i=0; i<totalPixels; i++){	  pixelArrangement[i].resize(3);	  for (int j=0; j<3; j++){	    pixelArrangement[i][j].resize(BytesPerPixel);	  }	}							//unsigned char pixelArrangement[totalPixels][3][BytesPerPixel];	//initialize the inputHistogram and pixelArrangement to 0	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int grayScale=0; grayScale<=255; grayScale++){	      inputHistogram[grayScale][channels] = 0;	  }	}		for (int channels=0; channels<BytesPerPixel; channels++){	  for (int i=0; i<3; i++){	    for (int j=0; j<(Height*Width); j++){	      pixelArrangement[j][i][channels] = 0;	    }	  }	}	//populate the histogram	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int row=0; row<Height; row++){	    for (int col=0; col<Width; col++){	      inputHistogram[Imagedata[row][col][channels]][channels]++ ;	    }	  }	}	//Arrange the pixels in increasing grayscale value	int counter = 0;	int totalCounter = 0;	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int grayScale=0; grayScale<=255; grayScale++){	    for (int row=0; row<Height; row++){	      for (int col=0; col<Width; col++){		if ((int)Imagedata[row][col][channels] == grayScale){		  pixelArrangement[counter][0][channels] = grayScale;		  pixelArrangement[counter][1][channels] = row;		  pixelArrangement[counter][2][channels] = col;		  counter++;		  totalCounter++;		}	      }	    }	  }	  if (counter!=(int)(Height*Width)){	    cout << "total pixel mismatch" << endl;	  }	  counter = 0;	}	//count the number of pixels per bin	int pixelsPerBin = (Height*Width)/256;	//Redistribute the pixels according to bins	int currentPixelVal = 0;	counter = 0;	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int i=0; i<(Height*Width); i++){	    int row = pixelArrangement[i][1][channels];	    int col = pixelArrangement[i][2][channels];	    if (counter==pixelsPerBin){	      counter=0;	      if (currentPixelVal<255){		currentPixelVal++;	      }	    }	    newImage[row][col][channels] = (unsigned char)currentPixelVal;	    counter++;	  }	  currentPixelVal=0;	  counter = 0;	}	// Write image data (filename specified by second argument) from image data matrix	if (!(file=fopen(argv[2],"wb"))) {		cout << "Cannot open file: " << argv[2] << endl;		exit(1);	}	fwrite(newImage, sizeof(unsigned char), Height*Width*BytesPerPixel, file);	fclose(file);	return 0;}