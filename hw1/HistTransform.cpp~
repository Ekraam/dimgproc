// Homework 1// This code performs histogram transform matching it to a gaussian distribution// Question 2.d// This code takes 6 arguments in the following format// program_name input_image.raw output_image_methodA.raw [BytesPerPixel = 1] [Width = 256] [Height = 256]// //// Name: Ekraam Sabir // USC ID: 1428-2892-90// email: esabir@usc.edu// #include <stdio.h>#include <iostream>#include <stdlib.h>#define _USE_MATH_DEFINES#include <math.h>#include <cmath>#include <vector>using namespace std;float erf(float x){  float approximation = (2/sqrt(M_PI)) * (x - pow(x,3)/3 + pow(x,5)/10 - pow(x,7)/42);  return approximation;}int main(int argc, char *argv[]){	// Define file pointer and variables	FILE *file;	int BytesPerPixel;	int Height = 256;	int Width = 256;		// Check for proper syntax	if (argc < 5){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout << "This program performs Histogram transform matching it to a gaussian distribution" << endl;		cout << "You must have 6 arguments in the following format" << endl;		cout << "program_name input_image.raw output_image_methodB.raw [BytesPerPixel = 1] [Width = 256] [Height = 256]" << endl;		return 0;	}	//Get the command line parameters in the appropriate variables	else{	  BytesPerPixel = atoi(argv[3]);	  Width = atoi(argv[4]);	  Height = atoi(argv[5]);	}			// Allocate image data array	unsigned char Imagedata[Height][Width][BytesPerPixel];	// Read image (filename specified by first argument) into image data matrix	if (!(file=fopen(argv[1],"rb"))) {		cout << "Cannot open file: " << argv[1] <<endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), Height*Width*BytesPerPixel, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////		//create a blank new image arrays	unsigned char newImage[Height][Width][BytesPerPixel];	float tempImage[Height][Width][BytesPerPixel];	vector<vector<float> > inputHistogram;	vector<vector<float> > targetHistogram;	vector<vector<float> > inputCDF;	vector<vector<float> > targetCDF;	inputHistogram.resize(256);	targetHistogram.resize(256);	inputCDF.resize(256);	targetCDF.resize(256);	for (int grayScale=0; grayScale<256; grayScale++){	  inputHistogram[grayScale].resize(BytesPerPixel);	  targetHistogram[grayScale].resize(BytesPerPixel);	  inputCDF[grayScale].resize(BytesPerPixel);	  targetCDF[grayScale].resize(BytesPerPixel);	}	int sigma = 40;	int mean = 125;	//initialize the inputHistogram 0	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int grayScale=0; grayScale<=255; grayScale++){	    inputHistogram[grayScale][channels] = 0;	  }	}		//populate the histogram	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int row=0; row<Height; row++){	    for (int col=0; col<Width; col++){	      inputHistogram[Imagedata[row][col][channels]][channels]++ ;	    }	  }	}	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int grayScale=0; grayScale<256; grayScale++){	    targetHistogram[grayScale][channels] = exp( -1 * pow(grayScale-mean,2)/(2*pow(sigma,2)))/(sqrt(2*M_PI)*sigma);	  }	}		//Normalize the input histogram	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int grayScale=0; grayScale<=255; grayScale++){	    inputHistogram[grayScale][channels] = inputHistogram[grayScale][channels]/(float)(Height*Width);	  }	}	//convert it to CDF	for (int channels=0; channels<BytesPerPixel; channels++){	  inputCDF[0][channels] = inputHistogram[0][channels];	  targetCDF[0][channels] = targetHistogram[0][channels];	  for (int grayScale=1; grayScale<=255; grayScale++){	    inputCDF[grayScale][channels] = inputHistogram[grayScale][channels]+inputCDF[grayScale-1][channels];	    targetCDF[grayScale][channels] = targetHistogram[grayScale][channels]+targetCDF[grayScale-1][channels];	  }	}	//compute the values for the output histogram	float min = 5000;	float max = -1;	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int row=0; row<Height; row++){	    for (int col=0; col<Width; col++){	      float inputCDFVal = inputCDF[ Imagedata[row][col][channels] ][channels];	      float closestMatch = 5000;	      float targetCDFGrayScale = 0;	      for (int i=0; i<256; i++){		float error = abs(inputCDFVal - targetCDF[i][channels]);		if (error<closestMatch){		  closestMatch = error;		  targetCDFGrayScale = i;		}	      }	      tempImage[row][col][channels] = targetCDFGrayScale;	      if (targetCDFGrayScale<min)		min = targetCDFGrayScale;	      if (targetCDFGrayScale>max)		max = targetCDFGrayScale;	    }	  }	}		cout<< "The min value " << min << endl;	cout<< "The max value " << max << endl;		//Renormalize the values to fit in the 8 bit range	for (int channels=0; channels<BytesPerPixel; channels++){	  for (int row=0; row<Height; row++){	    for (int col=0; col<Width; col++){	      	      newImage[row][col][channels] = (unsigned char)(255*(tempImage[row][col][channels]-min)/(max-min));	    }	  }	}		// Write image data (filename specified by second argument) from image data matrix	if (!(file=fopen(argv[2],"wb"))) {		cout << "Cannot open file: " << argv[2] << endl;		exit(1);	}	fwrite(newImage, sizeof(unsigned char), Height*Width*BytesPerPixel, file);	fclose(file);	return 0;}