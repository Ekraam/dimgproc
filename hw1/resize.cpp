// Homework 1// This code implements the resizing function// Question 1.a.2// This code takes 8 arguments in the following format// program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Width = 256] [Height = 256] [outputHeight = 100] [outputWidth = 100]//// Name: Ekraam Sabir // USC ID: 1428-2892-90// email: esabir@usc.edu// #include <stdio.h>#include <iostream>#include <stdlib.h>#include <math.h>using namespace std;int main(int argc, char *argv[]){	// Define file pointer and variables	FILE *file;	int BytesPerPixel;	int Height = 256;	int Width = 256;	int outputHeight, outputWidth;		// Check for proper syntax	if (argc < 8){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout << "This program is for image resizing to outputHeight and outputWidth" << endl;		cout << "You must have 8 arguments in the following format" << endl;		cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Width = 256] [Height = 256] [outputHeight = 100] [outputWidth = 100] " << endl;		return 0;	}	//Get the command line parameters in the appropriate variables	else{	  BytesPerPixel = atoi(argv[3]);	  Width = atoi(argv[4]);	  Height = atoi(argv[5]);	  outputHeight = atoi(argv[6]);	  outputWidth = atoi(argv[7]);	}			// Allocate image data array	unsigned char Imagedata[Height][Width][BytesPerPixel];	// Read image (filename specified by first argument) into image data matrix	if (!(file=fopen(argv[1],"rb"))) {		cout << "Cannot open file: " << argv[1] <<endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), Height*Width*BytesPerPixel, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////		//create a blank new iamge array	unsigned char newImage[outputHeight][outputWidth][BytesPerPixel];	//conversion ratio	float heightRatio = float(Height)/outputHeight;	float widthRatio = float(Width)/outputWidth;	//assign values to the cropped image element by element of each channel	for (int row=0; row<outputHeight; row++){	  for (int col=0; col<outputWidth; col++){	    //get the corresponding mapping values on source image for each pixel on resized image.	    float mappedHeight = heightRatio * row;	    float mappedWidth = widthRatio * col;	    	    //get the surrounding pixels in the source image for the mapped value	    int inputHeight1 = (int)floor(mappedHeight);	    int inputHeight2 = (int)ceil(mappedHeight);	    int inputWidth1 = (int)floor(mappedWidth);	    int inputWidth2 = (int)ceil(mappedWidth);	    	    //get the bilinear interpolated values from the source	    float a = mappedHeight - inputHeight1;	    float b = mappedWidth - inputWidth1;	    //The corresponding resize image values by bilinear interpolation	    newImage[row][col][0] = (unsigned char)((1-b)*((1-a)*Imagedata[inputHeight1][inputWidth1][0] + a*Imagedata[inputHeight2][inputWidth1][0]) + (b)*((1-a)*Imagedata[inputHeight1][inputWidth2][0] + a*Imagedata[inputHeight2][inputWidth2][0])); //Red Channel	    newImage[row][col][1] = (unsigned char)((1-b)*((1-a)*Imagedata[inputHeight1][inputWidth1][1] + a*Imagedata[inputHeight2][inputWidth1][1]) + (b)*((1-a)*Imagedata[inputHeight1][inputWidth2][1] + a*Imagedata[inputHeight2][inputWidth2][1])); //Green Channel	    newImage[row][col][2] = (unsigned char)((1-b)*((1-a)*Imagedata[inputHeight1][inputWidth1][2] + a*Imagedata[inputHeight2][inputWidth1][2]) + (b)*((1-a)*Imagedata[inputHeight1][inputWidth2][2] + a*Imagedata[inputHeight2][inputWidth2][2])); //Blue Channel	  }	}	// Write image data (filename specified by second argument) from image data matrix	if (!(file=fopen(argv[2],"wb"))) {		cout << "Cannot open file: " << argv[2] << endl;		exit(1);	}	fwrite(newImage, sizeof(unsigned char), outputHeight*outputWidth*BytesPerPixel, file);	fclose(file);	return 0;}