// Homework 2// This code implements error diffusion// Question 2.b// This code takes 6 arguments in the following format// program_name input_image.raw output_image.raw [Width = 256] [Height = 256] [option = FS/JJN/ST]// //// Name: Ekraam Sabir // USC ID: 1428-2892-90// email: esabir@usc.edu// #include <stdio.h>#include <iostream>#include <stdlib.h>#define _USE_MATH_DEFINES#include <math.h>#include <time.h>#include <cmath>#include <vector>#include <algorithm>#include <string>using namespace std;int main(int argc, char *argv[]){ 	// Define file pointer and variables	FILE *file;	int Height_butterfly = 256;	int Width_butterfly = 256;	int Height_fly = 256;	int Width_fly = 256;	int Height_probe = 256;	int Width_probe = 256;		// Check for proper syntax	if (argc < 13){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout << "This program performs analysis on rice image" << endl;		cout << "You must have 13 arguments in the following format" << endl;		cout << "program_name butterfly_image.raw fly_image.raw probe_image.raw outputButterfly_image.raw outputFly_image.raw outputProbe_image.raw [Width_butterfly = 256] [Height_butterfly = 256] [Width_fly = 256] [Height_fly = 256] [Width_probe = 256] [Height_probe = 256]" << endl;		return 0;	}	//Get the command line parameters in the appropriate variables	else{	  Width_butterfly = atoi(argv[7]);	  Height_butterfly = atoi(argv[8]);	  Width_fly = atoi(argv[9]);	  Height_fly = atoi(argv[10]);	  Width_probe = atoi(argv[11]);	  Height_probe = atoi(argv[12]);	}		// Allocate image data array	unsigned char butterflyImage[Height_butterfly][Width_butterfly];	unsigned char flyImage[Height_fly][Width_fly];	unsigned char probeImage[Height_probe][Width_probe];	// Read Image into image data matrix	if (!(file=fopen(argv[1],"rb"))) {		cout << "Cannot open file: " << argv[1] <<endl;		exit(1);	}	fread(butterflyImage, sizeof(unsigned char), Height_butterfly*Width_butterfly, file);	fclose(file);	// Read Image into image data matrix	if (!(file=fopen(argv[2],"rb"))) {		cout << "Cannot open file: " << argv[2] <<endl;		exit(1);	}	fread(flyImage, sizeof(unsigned char), Height_fly*Width_fly, file);	fclose(file);	// Read Image into image data matrix	if (!(file=fopen(argv[3],"rb"))) {		cout << "Cannot open file: " << argv[3] <<endl;		exit(1);	}	fread(probeImage, sizeof(unsigned char), Height_probe*Width_probe, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	//create blank new image arrays	unsigned char butterflyOutputImage[Height_butterfly][Width_butterfly];	unsigned char flyOutputImage[Height_fly][Width_fly];	unsigned char probeOutputImage[Height_probe][Width_probe];	// make boundary of input image black to avoid object touching the border	//butterfly	for (int row=0; row<Height_butterfly; row+=Height_butterfly-1){	  for (int col=0; col<Width_butterfly; col++){	    butterflyImage[row][col] = 0;	  }	}	for (int row=0; row<Height_butterfly; row++){	  for (int col=0; col<Width_butterfly; col+=Width_butterfly-1){	    butterflyImage[row][col] = 0;	  }	}	//fly	for (int row=0; row<Height_fly; row+=Height_fly-1){	  for (int col=0; col<Width_fly; col++){	    flyImage[row][col] = 0;	  }	}	for (int row=0; row<Height_fly; row++){	  for (int col=0; col<Width_fly; col+=Width_fly-1){	    flyImage[row][col] = 0;	  }	}	//probe	for (int row=0; row<Height_probe; row+=Height_probe-1){	  for (int col=0; col<Width_probe; col++){	    probeImage[row][col] = 0;	  }	}	for (int row=0; row<Height_probe; row++){	  for (int col=0; col<Width_probe; col+=Width_probe-1){	    probeImage[row][col] = 0;	  }	}	for (int butterfly=0; butterfly<1; butterfly++){	  // label image to store the connnected components	  vector<vector <int> > butterflyLabelImage_topLeft;	  butterflyLabelImage_topLeft.resize(Height_butterfly);	  for (int row=0; row<Height_butterfly; row++)	    butterflyLabelImage_topLeft[row].resize(Width_butterfly);	  	  vector<vector <int> > butterflyLabelImage_botRight;	  butterflyLabelImage_botRight.resize(Height_butterfly);	  for (int row=0; row<Height_butterfly; row++)	    butterflyLabelImage_botRight[row].resize(Width_butterfly);	  	  // populate the label image with complement of binary image - removing the holes	  	  //butterfly	  for (int row=0; row<Height_butterfly; row++){	    for (int col=0; col<Width_butterfly; col++){	      if (butterflyImage[row][col]==0){		butterflyLabelImage_topLeft[row][col] = 1;		butterflyLabelImage_botRight[row][col] = 1;	      }	      else{		butterflyLabelImage_topLeft[row][col] = 5000; // high label to white - least preferable label in later code when choosing min label		butterflyLabelImage_botRight[row][col] = 5000;	      }	    }	  }	  int labelCounter = 2;	  for (int row=1; row<Height_butterfly-1; row++){	    for (int col=1; col<Width_butterfly-1; col++){	      	      int mini = 0;	      	      if (butterflyLabelImage_topLeft[row][col]==1){				int n1 = butterflyLabelImage_topLeft[row-1][col-1];		int n2 = butterflyLabelImage_topLeft[row-1][col];		int n3 = butterflyLabelImage_topLeft[row-1][col+1];		int n4 = butterflyLabelImage_topLeft[row][col-1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  butterflyLabelImage_topLeft[row][col] = labelCounter;		  labelCounter++;		}		else		  butterflyLabelImage_topLeft[row][col] = mini;	      }	      	    }	  }	  	  // bottom right	  labelCounter = 2;	  for (int row=Height_butterfly-2; row>0; row--){	    for (int col=Width_butterfly-2; col>0; col--){	      	      int mini = 0;	      	      if (butterflyLabelImage_botRight[row][col]==1){				int n1 = butterflyLabelImage_botRight[row+1][col-1];		int n2 = butterflyLabelImage_botRight[row+1][col];		int n3 = butterflyLabelImage_botRight[row+1][col+1];		int n4 = butterflyLabelImage_botRight[row][col+1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  butterflyLabelImage_botRight[row][col] = labelCounter;		  labelCounter++;		}		else		  butterflyLabelImage_botRight[row][col] = mini;	      }	      	    }	  }	  	  // remove holes using the connected components in final image	  for (int row=0; row<Height_butterfly; row++){	    for (int col=0; col<Width_butterfly; col++){	      if (butterflyLabelImage_topLeft[row][col]==1 || butterflyLabelImage_botRight[row][col]==1)		butterflyOutputImage[row][col] = 0;	      else		butterflyOutputImage[row][col] = 255;	    }	  }	  	}	//fly	for (int fly=0; fly<1; fly++){	  	  vector<vector <int> > flyLabelImage_topLeft;	  flyLabelImage_topLeft.resize(Height_fly);	  for (int row=0; row<Height_fly; row++)	    flyLabelImage_topLeft[row].resize(Width_fly);	  vector<vector <int> > flyLabelImage_botRight;	  flyLabelImage_botRight.resize(Height_fly);	  for (int row=0; row<Height_fly; row++)	    flyLabelImage_botRight[row].resize(Width_fly);	  	  for (int row=0; row<Height_fly; row++){	    for (int col=0; col<Width_fly; col++){	      if (flyImage[row][col]==0){		flyLabelImage_topLeft[row][col] = 1;		flyLabelImage_botRight[row][col] = 1;	      }	      else{		flyLabelImage_topLeft[row][col] = 5000; // high label to white - least preferable label in later code when choosing min label		flyLabelImage_botRight[row][col] = 5000;	      }	    }	  }	 	  	  int labelCounter = 2;	  for (int row=1; row<Height_fly-1; row++){	    for (int col=1; col<Width_fly-1; col++){	      	      int mini = 0;	      	      if (flyLabelImage_topLeft[row][col]==1){				int n1 = flyLabelImage_topLeft[row-1][col-1];		int n2 = flyLabelImage_topLeft[row-1][col];		int n3 = flyLabelImage_topLeft[row-1][col+1];		int n4 = flyLabelImage_topLeft[row][col-1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  flyLabelImage_topLeft[row][col] = labelCounter;		  labelCounter++;		}		else		  flyLabelImage_topLeft[row][col] = mini;	      }	    }	  }	  // bot Right	  labelCounter = 2;	  for (int row=Height_fly-2; row>0; row--){	    for (int col=Width_fly-2; col>0; col--){	      	      int mini = 0;	      	      if (flyLabelImage_botRight[row][col]==1){				int n1 = flyLabelImage_botRight[row+1][col-1];		int n2 = flyLabelImage_botRight[row+1][col];		int n3 = flyLabelImage_botRight[row+1][col+1];		int n4 = flyLabelImage_botRight[row][col+1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  flyLabelImage_botRight[row][col] = labelCounter;		  labelCounter++;		}		else		  flyLabelImage_botRight[row][col] = mini;	      }	    }	  }	 	  	  // remove holes using the connected components in final image	  for (int row=0; row<Height_fly; row++){	    for (int col=0; col<Width_fly; col++){	      if (flyLabelImage_topLeft[row][col]==1 || flyLabelImage_botRight[row][col]==1)		flyOutputImage[row][col] = 0;	    else	      flyOutputImage[row][col] = 255;	    }	  }	}	//probe	for (int probe=0; probe<1; probe++){	  	  vector<vector <int> > probeLabelImage_topLeft;	  probeLabelImage_topLeft.resize(Height_probe);	  for (int row=0; row<Height_probe; row++)	    probeLabelImage_topLeft[row].resize(Width_probe);	  vector<vector <int> > probeLabelImage_botRight;	  probeLabelImage_botRight.resize(Height_probe);	  for (int row=0; row<Height_probe; row++)	    probeLabelImage_botRight[row].resize(Width_probe);	  	  for (int row=0; row<Height_probe; row++){	    for (int col=0; col<Width_probe; col++){	      if (probeImage[row][col]==0){		probeLabelImage_topLeft[row][col] = 1;		probeLabelImage_botRight[row][col] = 1;	      }	      else{		probeLabelImage_topLeft[row][col] = 5000; // high label to white - least preferable label in later code when choosing min label		probeLabelImage_botRight[row][col] = 5000;	      }	    }	  }	  	  // probeLookup vector	 	  	  int labelCounter = 2;	  for (int row=1; row<Height_probe-1; row++){	    for (int col=1; col<Width_probe-1; col++){	      	      int mini = 0;	      	      if (probeLabelImage_topLeft[row][col]==1){				int n1 = probeLabelImage_topLeft[row-1][col-1];		int n2 = probeLabelImage_topLeft[row-1][col];		int n3 = probeLabelImage_topLeft[row-1][col+1];		int n4 = probeLabelImage_topLeft[row][col-1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  probeLabelImage_topLeft[row][col] = labelCounter;		  labelCounter++;		}		else		  probeLabelImage_topLeft[row][col] = mini;	      }	    }	  }	  labelCounter = 2;	  for (int row=Height_probe-2; row>0; row--){	    for (int col=Width_probe-2; col>0; col--){	      	      int mini = 0;	      	      if (probeLabelImage_botRight[row][col]==1){				int n1 = probeLabelImage_botRight[row+1][col-1];		int n2 = probeLabelImage_botRight[row+1][col];		int n3 = probeLabelImage_botRight[row+1][col+1];		int n4 = probeLabelImage_botRight[row][col+1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  probeLabelImage_botRight[row][col] = labelCounter;		  labelCounter++;		}		else		  probeLabelImage_botRight[row][col] = mini;	      }	    }	  }		  	  // remove holes using the connected components in final image	  for (int row=0; row<Height_probe; row++){	    for (int col=0; col<Width_probe; col++){	      if (probeLabelImage_topLeft[row][col]==1 || probeLabelImage_botRight[row][col]==1)		probeOutputImage[row][col] = 0;	      else		probeOutputImage[row][col] = 255;	    }	  }	}	  	// Write image data from image data matrix		if (!(file=fopen(argv[4],"wb"))) {	  cout << "Cannot open file: " << argv[2] << endl;	  exit(1);	}	fwrite(butterflyOutputImage, sizeof(unsigned char), Height_butterfly*Width_butterfly, file);	fclose(file);	if (!(file=fopen(argv[5],"wb"))) {	  cout << "Cannot open file: " << argv[2] << endl;	  exit(1);	}	fwrite(flyOutputImage, sizeof(unsigned char), Height_fly*Width_fly, file);	fclose(file);	if (!(file=fopen(argv[6],"wb"))) {	  cout << "Cannot open file: " << argv[2] << endl;	  exit(1);	}	fwrite(probeOutputImage, sizeof(unsigned char), Height_probe*Width_probe, file);	fclose(file);       		return 0;}