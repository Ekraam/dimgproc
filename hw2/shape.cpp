// Homework 2// This code implements error diffusion// Question 2.b// This code takes 6 arguments in the following format// program_name input_image.raw output_image.raw [Width = 256] [Height = 256] [option = FS/JJN/ST]// //// Name: Ekraam Sabir // USC ID: 1428-2892-90// email: esabir@usc.edu// #include <stdio.h>#include <iostream>#include <stdlib.h>#define _USE_MATH_DEFINES#include <math.h>#include <time.h>#include <cmath>#include <vector>#include <algorithm>#include <string>using namespace std;int main(int argc, char *argv[]){ 	// Define file pointer and variables	FILE *file;	int Height_butterfly = 256;	int Width_butterfly = 256;	int Height_fly = 256;	int Width_fly = 256;	int Height_probe = 256;	int Width_probe = 256;		// Check for proper syntax	if (argc < 13){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		cout << "This program performs analysis on rice image" << endl;		cout << "You must have 13 arguments in the following format" << endl;		cout << "program_name butterfly_image.raw fly_image.raw probe_image.raw outputButterfly_image.raw outputFly_image.raw outputProbe_image.raw [Width_butterfly = 256] [Height_butterfly = 256] [Width_fly = 256] [Height_fly = 256] [Width_probe = 256] [Height_probe = 256]" << endl;		return 0;	}	//Get the command line parameters in the appropriate variables	else{	  Width_butterfly = atoi(argv[7]);	  Height_butterfly = atoi(argv[8]);	  Width_fly = atoi(argv[9]);	  Height_fly = atoi(argv[10]);	  Width_probe = atoi(argv[11]);	  Height_probe = atoi(argv[12]);	}		// Allocate image data array	unsigned char butterflyImage[Height_butterfly][Width_butterfly];	unsigned char flyImage[Height_fly][Width_fly];	unsigned char probeImage[Height_probe][Width_probe];	// Read Image into image data matrix	if (!(file=fopen(argv[1],"rb"))) {		cout << "Cannot open file: " << argv[1] <<endl;		exit(1);	}	fread(butterflyImage, sizeof(unsigned char), Height_butterfly*Width_butterfly, file);	fclose(file);	// Read Image into image data matrix	if (!(file=fopen(argv[2],"rb"))) {		cout << "Cannot open file: " << argv[2] <<endl;		exit(1);	}	fread(flyImage, sizeof(unsigned char), Height_fly*Width_fly, file);	fclose(file);	// Read Image into image data matrix	if (!(file=fopen(argv[3],"rb"))) {		cout << "Cannot open file: " << argv[3] <<endl;		exit(1);	}	fread(probeImage, sizeof(unsigned char), Height_probe*Width_probe, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	//create blank new image arrays	unsigned char butterflyOutputImage[Height_butterfly][Width_butterfly];	unsigned char flyOutputImage[Height_fly][Width_fly];	unsigned char probeOutputImage[Height_probe][Width_probe];	// make boundary of input image black to avoid object touching the border	//butterfly	for (int row=0; row<Height_butterfly; row+=Height_butterfly-1){	  for (int col=0; col<Width_butterfly; col++){	    butterflyImage[row][col] = 0;	  }	}	for (int row=0; row<Height_butterfly; row++){	  for (int col=0; col<Width_butterfly; col+=Width_butterfly-1){	    butterflyImage[row][col] = 0;	  }	}	//fly	for (int row=0; row<Height_fly; row+=Height_fly-1){	  for (int col=0; col<Width_fly; col++){	    flyImage[row][col] = 0;	  }	}	for (int row=0; row<Height_fly; row++){	  for (int col=0; col<Width_fly; col+=Width_fly-1){	    flyImage[row][col] = 0;	  }	}	//probe	for (int row=0; row<Height_probe; row+=Height_probe-1){	  for (int col=0; col<Width_probe; col++){	    probeImage[row][col] = 0;	  }	}	for (int row=0; row<Height_probe; row++){	  for (int col=0; col<Width_probe; col+=Width_probe-1){	    probeImage[row][col] = 0;	  }	}	for (int butterfly=0; butterfly<1; butterfly++){	  // label image to store the connnected components	  vector<vector <int> > butterflyLabelImage_topLeft;	  butterflyLabelImage_topLeft.resize(Height_butterfly);	  for (int row=0; row<Height_butterfly; row++)	    butterflyLabelImage_topLeft[row].resize(Width_butterfly);	  	  vector<vector <int> > butterflyLabelImage_botRight;	  butterflyLabelImage_botRight.resize(Height_butterfly);	  for (int row=0; row<Height_butterfly; row++)	    butterflyLabelImage_botRight[row].resize(Width_butterfly);	  	  // populate the label image with complement of binary image - removing the holes	  	  //butterfly	  for (int row=0; row<Height_butterfly; row++){	    for (int col=0; col<Width_butterfly; col++){	      if (butterflyImage[row][col]==0){		butterflyLabelImage_topLeft[row][col] = 1;		butterflyLabelImage_botRight[row][col] = 1;	      }	      else{		butterflyLabelImage_topLeft[row][col] = 5000; // high label to white - least preferable label in later code when choosing min label		butterflyLabelImage_botRight[row][col] = 5000;	      }	    }	  }	  int labelCounter = 2;	  for (int row=1; row<Height_butterfly-1; row++){	    for (int col=1; col<Width_butterfly-1; col++){	      	      int mini = 0;	      	      if (butterflyLabelImage_topLeft[row][col]==1){				int n1 = butterflyLabelImage_topLeft[row-1][col-1];		int n2 = butterflyLabelImage_topLeft[row-1][col];		int n3 = butterflyLabelImage_topLeft[row-1][col+1];		int n4 = butterflyLabelImage_topLeft[row][col-1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  butterflyLabelImage_topLeft[row][col] = labelCounter;		  labelCounter++;		}		else		  butterflyLabelImage_topLeft[row][col] = mini;	      }	      	    }	  }	  	  // bottom right	  labelCounter = 2;	  for (int row=Height_butterfly-2; row>0; row--){	    for (int col=Width_butterfly-2; col>0; col--){	      	      int mini = 0;	      	      if (butterflyLabelImage_botRight[row][col]==1){				int n1 = butterflyLabelImage_botRight[row+1][col-1];		int n2 = butterflyLabelImage_botRight[row+1][col];		int n3 = butterflyLabelImage_botRight[row+1][col+1];		int n4 = butterflyLabelImage_botRight[row][col+1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  butterflyLabelImage_botRight[row][col] = labelCounter;		  labelCounter++;		}		else		  butterflyLabelImage_botRight[row][col] = mini;	      }	      	    }	  }	  	  // remove holes using the connected components in final image	  for (int row=0; row<Height_butterfly; row++){	    for (int col=0; col<Width_butterfly; col++){	      if (butterflyLabelImage_topLeft[row][col]==1 || butterflyLabelImage_botRight[row][col]==1)		butterflyOutputImage[row][col] = 0;	      else		butterflyOutputImage[row][col] = 255;	    }	  }	  	}	//fly	for (int fly=0; fly<1; fly++){	  	  vector<vector <int> > flyLabelImage_topLeft;	  flyLabelImage_topLeft.resize(Height_fly);	  for (int row=0; row<Height_fly; row++)	    flyLabelImage_topLeft[row].resize(Width_fly);	  vector<vector <int> > flyLabelImage_botRight;	  flyLabelImage_botRight.resize(Height_fly);	  for (int row=0; row<Height_fly; row++)	    flyLabelImage_botRight[row].resize(Width_fly);	  	  for (int row=0; row<Height_fly; row++){	    for (int col=0; col<Width_fly; col++){	      if (flyImage[row][col]==0){		flyLabelImage_topLeft[row][col] = 1;		flyLabelImage_botRight[row][col] = 1;	      }	      else{		flyLabelImage_topLeft[row][col] = 5000; // high label to white - least preferable label in later code when choosing min label		flyLabelImage_botRight[row][col] = 5000;	      }	    }	  }	 	  	  int labelCounter = 2;	  for (int row=1; row<Height_fly-1; row++){	    for (int col=1; col<Width_fly-1; col++){	      	      int mini = 0;	      	      if (flyLabelImage_topLeft[row][col]==1){				int n1 = flyLabelImage_topLeft[row-1][col-1];		int n2 = flyLabelImage_topLeft[row-1][col];		int n3 = flyLabelImage_topLeft[row-1][col+1];		int n4 = flyLabelImage_topLeft[row][col-1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  flyLabelImage_topLeft[row][col] = labelCounter;		  labelCounter++;		}		else		  flyLabelImage_topLeft[row][col] = mini;	      }	    }	  }	  // bot Right	  labelCounter = 2;	  for (int row=Height_fly-2; row>0; row--){	    for (int col=Width_fly-2; col>0; col--){	      	      int mini = 0;	      	      if (flyLabelImage_botRight[row][col]==1){				int n1 = flyLabelImage_botRight[row+1][col-1];		int n2 = flyLabelImage_botRight[row+1][col];		int n3 = flyLabelImage_botRight[row+1][col+1];		int n4 = flyLabelImage_botRight[row][col+1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  flyLabelImage_botRight[row][col] = labelCounter;		  labelCounter++;		}		else		  flyLabelImage_botRight[row][col] = mini;	      }	    }	  }	 	  	  // remove holes using the connected components in final image	  for (int row=0; row<Height_fly; row++){	    for (int col=0; col<Width_fly; col++){	      if (flyLabelImage_topLeft[row][col]==1 || flyLabelImage_botRight[row][col]==1)		flyOutputImage[row][col] = 0;	    else	      flyOutputImage[row][col] = 255;	    }	  }	}	//probe	for (int probe=0; probe<1; probe++){	  	  vector<vector <int> > probeLabelImage_topLeft;	  probeLabelImage_topLeft.resize(Height_probe);	  for (int row=0; row<Height_probe; row++)	    probeLabelImage_topLeft[row].resize(Width_probe);	  vector<vector <int> > probeLabelImage_botRight;	  probeLabelImage_botRight.resize(Height_probe);	  for (int row=0; row<Height_probe; row++)	    probeLabelImage_botRight[row].resize(Width_probe);	  	  for (int row=0; row<Height_probe; row++){	    for (int col=0; col<Width_probe; col++){	      if (probeImage[row][col]==0){		probeLabelImage_topLeft[row][col] = 1;		probeLabelImage_botRight[row][col] = 1;	      }	      else{		probeLabelImage_topLeft[row][col] = 5000; // high label to white - least preferable label in later code when choosing min label		probeLabelImage_botRight[row][col] = 5000;	      }	    }	  }	  	  // probeLookup vector	 	  	  int labelCounter = 2;	  for (int row=1; row<Height_probe-1; row++){	    for (int col=1; col<Width_probe-1; col++){	      	      int mini = 0;	      	      if (probeLabelImage_topLeft[row][col]==1){				int n1 = probeLabelImage_topLeft[row-1][col-1];		int n2 = probeLabelImage_topLeft[row-1][col];		int n3 = probeLabelImage_topLeft[row-1][col+1];		int n4 = probeLabelImage_topLeft[row][col-1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  probeLabelImage_topLeft[row][col] = labelCounter;		  labelCounter++;		}		else		  probeLabelImage_topLeft[row][col] = mini;	      }	    }	  }	  labelCounter = 2;	  for (int row=Height_probe-2; row>0; row--){	    for (int col=Width_probe-2; col>0; col--){	      	      int mini = 0;	      	      if (probeLabelImage_botRight[row][col]==1){				int n1 = probeLabelImage_botRight[row+1][col-1];		int n2 = probeLabelImage_botRight[row+1][col];		int n3 = probeLabelImage_botRight[row+1][col+1];		int n4 = probeLabelImage_botRight[row][col+1];				mini = min(n4, min(n2, min(n1, n3)));				if (mini==5000){		  probeLabelImage_botRight[row][col] = labelCounter;		  labelCounter++;		}		else		  probeLabelImage_botRight[row][col] = mini;	      }	    }	  }		  	  // remove holes using the connected components in final image	  for (int row=0; row<Height_probe; row++){	    for (int col=0; col<Width_probe; col++){	      if (probeLabelImage_topLeft[row][col]==1 || probeLabelImage_botRight[row][col]==1)		probeOutputImage[row][col] = 0;	      else		probeOutputImage[row][col] = 255;	    }	  }	}	// boundary smoothing	do{	  //initialize arrays	  vector<vector <int> > butterflyCopy;	  butterflyCopy.resize(Height_butterfly);	  for (int row=0; row<Height_butterfly; row++)	    butterflyCopy[row].resize(Width_butterfly);	  vector<vector <int> > flyCopy;	  flyCopy.resize(Height_fly);	  for (int row=0; row<Height_fly; row++)	    flyCopy[row].resize(Width_fly);	  vector<vector <int> > probeCopy;	  probeCopy.resize(Height_probe);	  for (int row=0; row<Height_probe; row++)	    probeCopy[row].resize(Width_probe);	  // populate them	  for (int row=0; row<Height_butterfly; row++){	    for (int col=0; col<Width_butterfly; col++){	      butterflyCopy[row][col] = butterflyOutputImage[row][col];	    }	  }	  	  for (int row=0; row<Height_fly; row++){	    for (int col=0; col<Width_fly; col++){	      flyCopy[row][col] = flyOutputImage[row][col];	    }	  }	  for (int row=0; row<Height_probe; row++){	    for (int col=0; col<Width_probe; col++){	      probeCopy[row][col] = probeOutputImage[row][col];	    }	  }	  // smoothing on all the outputs	  	  for (int row=1; row<Height_butterfly-1; row++){	    for (int col=1; col<Width_butterfly-1; col++){	      if (butterflyCopy[row][col]==0){		if (butterflyCopy[row-1][col-1]+butterflyCopy[row-1][col]+butterflyCopy[row-1][col+1]+butterflyCopy[row][col-1]+butterflyCopy[row][col+1]+butterflyCopy[row+1][col-1]+butterflyCopy[row+1][col]+butterflyCopy[row+1][col+1]>=1275)		  butterflyOutputImage[row][col] = 255;	      }	    }	  }	  for (int row=1; row<Height_fly-1; row++){	    for (int col=1; col<Width_fly-1; col++){	      if (flyCopy[row][col]==0){		if (flyCopy[row-1][col-1]+flyCopy[row-1][col]+flyCopy[row-1][col+1]+flyCopy[row][col-1]+flyCopy[row][col+1]+flyCopy[row+1][col-1]+flyCopy[row+1][col]+flyCopy[row+1][col+1]>=1275)		  flyOutputImage[row][col] = 255;	      }	    }	  }	  for (int row=1; row<Height_probe-1; row++){	    for (int col=1; col<Width_probe-1; col++){	      if (probeCopy[row][col]==0){		if (probeCopy[row-1][col-1]+probeCopy[row-1][col]+probeCopy[row-1][col+1]+probeCopy[row][col-1]+probeCopy[row][col+1]+probeCopy[row+1][col-1]+probeCopy[row+1][col]+probeCopy[row+1][col+1]>=1275)		  probeOutputImage[row][col] = 255;	      }	    }	  }	}while(false);	// THINNING	vector<vector <int> > butterflyThinImage;	butterflyThinImage.resize(Height_butterfly);	for (int row=0; row<Height_butterfly; row++)	  butterflyThinImage[row].resize(Width_butterfly);	vector<vector <int> > flyThinImage;	flyThinImage.resize(Height_fly);	for (int row=0; row<Height_fly; row++)	  flyThinImage[row].resize(Width_fly);	vector<vector <int> > probeThinImage;	probeThinImage.resize(Height_probe);	for (int row=0; row<Height_probe; row++)	  probeThinImage[row].resize(Width_probe);		do{	  	  bool change = true;	  vector<vector <int> > conM;	  conM.resize(Height_butterfly);	  for (int row=0; row<Height_butterfly; row++)	    conM[row].resize(Width_butterfly);	  	  for (int row=0; row<Height_butterfly; row++){	    for (int col=0; col<Width_butterfly; col++){	      butterflyThinImage[row][col] = butterflyOutputImage[row][col];	    }	  }	  	  change = true;	  while (change){	    	    for (int row=0; row<Height_butterfly; row++){	      for (int col=0; col<Width_butterfly; col++){		  conM[row][col]=0;	      }	    }	    	    for (int row=1; row<Height_butterfly-1; row++){	      for (int col=1; col<Width_butterfly-1; col++){				if (butterflyThinImage[row][col]==255){		  		  int M1 = butterflyThinImage[row-1][col-1];		  int M2 = butterflyThinImage[row-1][col];		  int M3 = butterflyThinImage[row-1][col+1];		  int M4 = butterflyThinImage[row][col-1];		  int M6 = butterflyThinImage[row][col+1];		  int M7 = butterflyThinImage[row+1][col-1];		  int M8 = butterflyThinImage[row+1][col];		  int M9 = butterflyThinImage[row+1][col+1];		  		  int bond = 0;		  		  if (M1==255)		    bond += 1;		  if (M2==255)		    bond += 2;		  if (M3==255)		      bond += 1;		  if (M4==255)		    bond += 2;		  if (M6==255)		    bond += 2;		  if (M7==255)		    bond += 1;		  if (M8==255)		    bond += 2;		  if (M9==255)		    bond += 1;		    		  if (bond==4 && ((M1==255 && M2==255 && M3==255) || (M3==255 && M6==255 && M9==255) || (M7==255 && M8==255 && M9==255) || (M1==255 && M4==255 && M7==255) || (M2+M6==255*2) || (M6+M8==255*2) || (M8+M4==255*2) || (M4+M2==255*2)))		    conM[row][col] = 1;		  		  if (bond==5 && ((M1==255 && M2==255 && M6==255) || (M2==255 && M6==255 && M9==255) || (M4==255 && M2==255 && M3==255) || (M3==255 && M6==255 && M8==255) || (M2==255 && M3==255 && M6==255) || (M1==255 && M2==255 && M4==255) || (M4==255 && M7==255 && M8==255) || (M6==255 && M8==255 && M9==255)))		      conM[row][col] = 1;		  		  if (bond==6 && ((M1==255 && M2==255 && M6==255 && M9==255) || (M2==255 && M3==255 && M4==255 && M7==255) || (M1==255 && M2==255 && M3==255 && M6==255) || (M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255) || (M1==255 && M2==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255) || (M4==255 && M7==255 && M8==255 && M9==255) || (M6==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==7 && ((M1==255 && M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M7==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==8 && ((M1==0 && M4==0 && M7==0) || (M1==0 && M2==0 && M3==0) || (M3==0 && M6==0 && M9==0) || (M7==0 && M8==0 && M9==0)))		    conM[row][col] = 1;		  		  if (bond==9 && ((M1==0 && M2==0) || (M2==0 && M3==0) || (M3==0 && M6==0) || (M6==0 && M9==0) || (M9==0 && M8==0) || (M8==0 && M7==0) || (M7==0 && M4==0) || (M4==0 && M1==0)))		    conM[row][col] = 1;		  		  if (bond==10 && (M2==0 || M4==0 || M6==0 || M8==0))		    conM[row][col] = 1;		  		}	      }	    }	    	    change = false;	    // unconditional mark pattern application - stage 2	    for (int row=1; row<Height_butterfly-1; row++){	      for (int col=1; col<Width_butterfly-1; col++){				int M1 = conM[row-1][col-1];		int M2 = conM[row-1][col];		int M3 = conM[row-1][col+1];		int M4 = conM[row][col-1];		int M5 = conM[row][col];		int M6 = conM[row][col+1];		int M7 = conM[row+1][col-1];		int M8 = conM[row+1][col];		int M9 = conM[row+1][col+1];						if (M5==1){		  if ( (M1==1 && M2+M3+M4+M6+M7+M8+M9==0) || (M3==1 && M1+M2+M4+M6+M7+M8+M9==0))		    butterflyThinImage[row][col] = 255;		  else if ( (M8==1 && M1+M2+M3+M4+M6+M7+M9==0) || (M6==1 && M1+M2+M3+M4+M7+M8+M9==0))		    butterflyThinImage[row][col] = 255;		  else if ((M1+M2==2 && M3+M4+M6+M7+M8+M9==0) || (M2+M3==2 && M1+M4+M6+M7+M8+M9==0) || (M3+M6==2 && M1+M2+M4+M7+M8+M9==0) || (M6+M9==2 && M1+M2+M3+M4+M7+M8==0) || (M9+M8==2 && M1+M2+M3+M4+M6+M7==0) || (M8+M7==2 && M1+M2+M3+M4+M6+M9==0) || (M7+M4==2 && M1+M2+M3+M6+M8+M9==0) || (M4+M1==2 && M2+M3+M6+M7+M8+M9==0))		    butterflyThinImage[row][col] = 255;		  else if ((M2+M3+M4==3 && M1+M6+M7+M8+M9==0) || (M1+M2+M6==3 && M3+M4+M7+M8+M9==0) || (M2+M6+M9==3 && M1+M3+M4+M7+M8==0) || (M3+M6+M8==3 && M1+M2+M4+M7+M9==0)) //|| (M4+M7+M9==3 && M1+M2+M3+M6+M8==0))		    butterflyThinImage[row][col] = 255;		  else if ((M3+M7==2 && M2+M6>=1 && M1+M4+M8+M9==0) || (M1+M9==2 && M2+M4>=1 && M3+M6+M7+M8==0) || (M3+M7==2 && M4+M8>=1 && M1+M2+M6+M9==0) || (M1+M9==2 && M6+M8>=1 && M2+M3+M4+M7==0))		    butterflyThinImage[row][col] = 255;		  else if (M1+M2+M4==3)		    butterflyThinImage[row][col] = 255;		  else if ((M2+M4+M6==3 && M3+M8+M9==0) || (M2+M4+M6==3 && M1+M7+M8==0) || (M8+M4+M6==3 && M1+M2+M7==0) || (M8+M4+M6==3 && M2+M3+M9==0) || (M2+M4+M8==3 && M6+M7+M9==0) || (M2+M4+M8==3 && M1+M3+M6==0) || (M2+M6+M8==3 && M1+M3+M4==0) || (M2+M6+M8==3 && M4+M7+M9==0))		    butterflyThinImage[row][col] = 255;		  else if ( (M1+M3==2 && M7+M8+M9>=1) || (M1+M7==2 && M3+M6+M9>=1) || (M7+M9==2 && M1+M2+M3>=1) || (M3+M9==2 && M1+M4+M7>=1) )		      butterflyThinImage[row][col] = 255;		  else if ( (M2+M6+M7==3 && M3+M4+M8==0) || (M2+M4+M9==3 && M1+M6+M8==0) || (M3+M4+M8==3 && M2+M6+M7==0) || (M1+M6+M8==3 && M2+M4+M9==0))		    butterflyThinImage[row][col] = 255;		  else{		    butterflyThinImage[row][col] = 0;		    change = true;		  }		}			      }	    }	  }	}while(false);	// fly		do{	  	  bool change = true;	  vector<vector <int> > conM;	  conM.resize(Height_fly);	  for (int row=0; row<Height_fly; row++)	    conM[row].resize(Width_fly);	  	  for (int row=0; row<Height_fly; row++){	    for (int col=0; col<Width_fly; col++){	      flyThinImage[row][col] = flyOutputImage[row][col];	    }	  }	  	  change = true;	  while (change){	    	    for (int row=0; row<Height_fly; row++){	      for (int col=0; col<Width_fly; col++){		  conM[row][col]=0;	      }	    }	    	    for (int row=1; row<Height_fly-1; row++){	      for (int col=1; col<Width_fly-1; col++){				if (flyThinImage[row][col]==255){		  		  int M1 = flyThinImage[row-1][col-1];		  int M2 = flyThinImage[row-1][col];		  int M3 = flyThinImage[row-1][col+1];		  int M4 = flyThinImage[row][col-1];		  int M6 = flyThinImage[row][col+1];		  int M7 = flyThinImage[row+1][col-1];		  int M8 = flyThinImage[row+1][col];		  int M9 = flyThinImage[row+1][col+1];		  		  int bond = 0;		  		  if (M1==255)		    bond += 1;		  if (M2==255)		    bond += 2;		  if (M3==255)		      bond += 1;		  if (M4==255)		    bond += 2;		  if (M6==255)		    bond += 2;		  if (M7==255)		    bond += 1;		  if (M8==255)		    bond += 2;		  if (M9==255)		    bond += 1;		    		  if (bond==4 && ((M1==255 && M2==255 && M3==255) || (M3==255 && M6==255 && M9==255) || (M7==255 && M8==255 && M9==255) || (M1==255 && M4==255 && M7==255) || (M2+M6==255*2) || (M6+M8==255*2) || (M8+M4==255*2) || (M4+M2==255*2)))		    conM[row][col] = 1;		  		  if (bond==5 && ((M1==255 && M2==255 && M6==255) || (M2==255 && M6==255 && M9==255) || (M4==255 && M2==255 && M3==255) || (M3==255 && M6==255 && M8==255) || (M2==255 && M3==255 && M6==255) || (M1==255 && M2==255 && M4==255) || (M4==255 && M7==255 && M8==255) || (M6==255 && M8==255 && M9==255)))		      conM[row][col] = 1;		  		  if (bond==6 && ((M1==255 && M2==255 && M6==255 && M9==255) || (M2==255 && M3==255 && M4==255 && M7==255) || (M1==255 && M2==255 && M3==255 && M6==255) || (M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255) || (M1==255 && M2==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255) || (M4==255 && M7==255 && M8==255 && M9==255) || (M6==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==7 && ((M1==255 && M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M7==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==8 && ((M1==0 && M4==0 && M7==0) || (M1==0 && M2==0 && M3==0) || (M3==0 && M6==0 && M9==0) || (M7==0 && M8==0 && M9==0)))		    conM[row][col] = 1;		  		  if (bond==9 && ((M1==0 && M2==0) || (M2==0 && M3==0) || (M3==0 && M6==0) || (M6==0 && M9==0) || (M9==0 && M8==0) || (M8==0 && M7==0) || (M7==0 && M4==0) || (M4==0 && M1==0)))		    conM[row][col] = 1;		  		  if (bond==10 && (M2==0 || M4==0 || M6==0 || M8==0))		    conM[row][col] = 1;		  		}	      }	    }	    	    change = false;	    // unconditional mark pattern application - stage 2	    for (int row=1; row<Height_fly-1; row++){	      for (int col=1; col<Width_fly-1; col++){				int M1 = conM[row-1][col-1];		int M2 = conM[row-1][col];		int M3 = conM[row-1][col+1];		int M4 = conM[row][col-1];		int M5 = conM[row][col];		int M6 = conM[row][col+1];		int M7 = conM[row+1][col-1];		int M8 = conM[row+1][col];		int M9 = conM[row+1][col+1];				//if (row==101 && (col==594 || col==595))		//cout<< M1 << " " << M2 << " " << M3 << " " << M4 << " " << M5 << " " << M6 << " " << M7 << " " << M8 << " " << M9 << endl;				if (M5==1){		  if ( (M1==1 && M2+M3+M4+M6+M7+M8+M9==0) || (M3==1 && M1+M2+M4+M6+M7+M8+M9==0))		    flyThinImage[row][col] = 255;		  else if ( (M8==1 && M1+M2+M3+M4+M6+M7+M9==0) || (M6==1 && M1+M2+M3+M4+M7+M8+M9==0))		    flyThinImage[row][col] = 255;		  else if ((M1+M2==2 && M3+M4+M6+M7+M8+M9==0) || (M2+M3==2 && M1+M4+M6+M7+M8+M9==0) || (M3+M6==2 && M1+M2+M4+M7+M8+M9==0) || (M6+M9==2 && M1+M2+M3+M4+M7+M8==0) || (M9+M8==2 && M1+M2+M3+M4+M6+M7==0) || (M8+M7==2 && M1+M2+M3+M4+M6+M9==0) || (M7+M4==2 && M1+M2+M3+M6+M8+M9==0) || (M4+M1==2 && M2+M3+M6+M7+M8+M9==0))		    flyThinImage[row][col] = 255;		  else if ((M2+M3+M4==3 && M1+M6+M7+M8+M9==0) || (M1+M2+M6==3 && M3+M4+M7+M8+M9==0) || (M2+M6+M9==3 && M1+M3+M4+M7+M8==0) || (M3+M6+M8==3 && M1+M2+M4+M7+M9==0)) //|| (M4+M7+M9==3 && M1+M2+M3+M6+M8==0))		    flyThinImage[row][col] = 255;		  else if ((M3+M7==2 && M2+M6>=1 && M1+M4+M8+M9==0) || (M1+M9==2 && M2+M4>=1 && M3+M6+M7+M8==0) || (M3+M7==2 && M4+M8>=1 && M1+M2+M6+M9==0) || (M1+M9==2 && M6+M8>=1 && M2+M3+M4+M7==0))		    flyThinImage[row][col] = 255;		  else if (M1+M2+M4==3)		    flyThinImage[row][col] = 255;		  else if ((M2+M4+M6==3 && M3+M8+M9==0) || (M2+M4+M6==3 && M1+M7+M8==0) || (M8+M4+M6==3 && M1+M2+M7==0) || (M8+M4+M6==3 && M2+M3+M9==0) || (M2+M4+M8==3 && M6+M7+M9==0) || (M2+M4+M8==3 && M1+M3+M6==0) || (M2+M6+M8==3 && M1+M3+M4==0) || (M2+M6+M8==3 && M4+M7+M9==0))		    flyThinImage[row][col] = 255;		  else if ( (M1+M3==2 && M7+M8+M9>=1) || (M1+M7==2 && M3+M6+M9>=1) || (M7+M9==2 && M1+M2+M3>=1) || (M3+M9==2 && M1+M4+M7>=1) )		      flyThinImage[row][col] = 255;		  else if ( (M2+M6+M7==3 && M3+M4+M8==0) || (M2+M4+M9==3 && M1+M6+M8==0) || (M3+M4+M8==3 && M2+M6+M7==0) || (M1+M6+M8==3 && M2+M4+M9==0))		    flyThinImage[row][col] = 255;		  else{		    flyThinImage[row][col] = 0;		    change = true;		  }		}			      }	    }	  }	}while(false);	// probe	do{	  	  bool change = true;	  vector<vector <int> > conM;	  conM.resize(Height_probe);	  for (int row=0; row<Height_probe; row++)	    conM[row].resize(Width_probe);	  	  for (int row=0; row<Height_probe; row++){	    for (int col=0; col<Width_probe; col++){	      probeThinImage[row][col] = probeOutputImage[row][col];	    }	  }	  	  change = true;	  while (change){	    	    for (int row=0; row<Height_probe; row++){	      for (int col=0; col<Width_probe; col++){		  conM[row][col]=0;	      }	    }	    	    for (int row=1; row<Height_probe-1; row++){	      for (int col=1; col<Width_probe-1; col++){				if (probeThinImage[row][col]==255){		  		  int M1 = probeThinImage[row-1][col-1];		  int M2 = probeThinImage[row-1][col];		  int M3 = probeThinImage[row-1][col+1];		  int M4 = probeThinImage[row][col-1];		  int M6 = probeThinImage[row][col+1];		  int M7 = probeThinImage[row+1][col-1];		  int M8 = probeThinImage[row+1][col];		  int M9 = probeThinImage[row+1][col+1];		  		  int bond = 0;		  		  if (M1==255)		    bond += 1;		  if (M2==255)		    bond += 2;		  if (M3==255)		      bond += 1;		  if (M4==255)		    bond += 2;		  if (M6==255)		    bond += 2;		  if (M7==255)		    bond += 1;		  if (M8==255)		    bond += 2;		  if (M9==255)		    bond += 1;		    		  if (bond==4 && ((M1==255 && M2==255 && M3==255) || (M3==255 && M6==255 && M9==255) || (M7==255 && M8==255 && M9==255) || (M1==255 && M4==255 && M7==255) || (M2+M6==255*2) || (M6+M8==255*2) || (M8+M4==255*2) || (M4+M2==255*2)))		    conM[row][col] = 1;		  		  if (bond==5 && ((M1==255 && M2==255 && M6==255) || (M2==255 && M6==255 && M9==255) || (M4==255 && M2==255 && M3==255) || (M3==255 && M6==255 && M8==255) || (M2==255 && M3==255 && M6==255) || (M1==255 && M2==255 && M4==255) || (M4==255 && M7==255 && M8==255) || (M6==255 && M8==255 && M9==255)))		      conM[row][col] = 1;		  		  if (bond==6 && ((M1==255 && M2==255 && M6==255 && M9==255) || (M2==255 && M3==255 && M4==255 && M7==255) || (M1==255 && M2==255 && M3==255 && M6==255) || (M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255) || (M1==255 && M2==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255) || (M4==255 && M7==255 && M8==255 && M9==255) || (M6==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==7 && ((M1==255 && M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M7==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==8 && ((M1==0 && M4==0 && M7==0) || (M1==0 && M2==0 && M3==0) || (M3==0 && M6==0 && M9==0) || (M7==0 && M8==0 && M9==0)))		    conM[row][col] = 1;		  		  if (bond==9 && ((M1==0 && M2==0) || (M2==0 && M3==0) || (M3==0 && M6==0) || (M6==0 && M9==0) || (M9==0 && M8==0) || (M8==0 && M7==0) || (M7==0 && M4==0) || (M4==0 && M1==0)))		    conM[row][col] = 1;		  		  if (bond==10 && (M2==0 || M4==0 || M6==0 || M8==0))		    conM[row][col] = 1;		  		}	      }	    }	    	    change = false;	    // unconditional mark pattern application - stage 2	    for (int row=1; row<Height_probe-1; row++){	      for (int col=1; col<Width_probe-1; col++){				int M1 = conM[row-1][col-1];		int M2 = conM[row-1][col];		int M3 = conM[row-1][col+1];		int M4 = conM[row][col-1];		int M5 = conM[row][col];		int M6 = conM[row][col+1];		int M7 = conM[row+1][col-1];		int M8 = conM[row+1][col];		int M9 = conM[row+1][col+1];						if (M5==1){		  if ( (M1==1 && M2+M3+M4+M6+M7+M8+M9==0) || (M3==1 && M1+M2+M4+M6+M7+M8+M9==0))		    probeThinImage[row][col] = 255;		  else if ( (M8==1 && M1+M2+M3+M4+M6+M7+M9==0) || (M6==1 && M1+M2+M3+M4+M7+M8+M9==0))		    probeThinImage[row][col] = 255;		  else if ((M1+M2==2 && M3+M4+M6+M7+M8+M9==0) || (M2+M3==2 && M1+M4+M6+M7+M8+M9==0) || (M3+M6==2 && M1+M2+M4+M7+M8+M9==0) || (M6+M9==2 && M1+M2+M3+M4+M7+M8==0) || (M9+M8==2 && M1+M2+M3+M4+M6+M7==0) || (M8+M7==2 && M1+M2+M3+M4+M6+M9==0) || (M7+M4==2 && M1+M2+M3+M6+M8+M9==0) || (M4+M1==2 && M2+M3+M6+M7+M8+M9==0))		    probeThinImage[row][col] = 255;		  else if ((M2+M3+M4==3 && M1+M6+M7+M8+M9==0) || (M1+M2+M6==3 && M3+M4+M7+M8+M9==0) || (M2+M6+M9==3 && M1+M3+M4+M7+M8==0) || (M3+M6+M8==3 && M1+M2+M4+M7+M9==0)) //|| (M4+M7+M9==3 && M1+M2+M3+M6+M8==0))		    probeThinImage[row][col] = 255;		  else if ((M3+M7==2 && M2+M6>=1 && M1+M4+M8+M9==0) || (M1+M9==2 && M2+M4>=1 && M3+M6+M7+M8==0) || (M3+M7==2 && M4+M8>=1 && M1+M2+M6+M9==0) || (M1+M9==2 && M6+M8>=1 && M2+M3+M4+M7==0))		    probeThinImage[row][col] = 255;		  else if (M1+M2+M4==3)		    probeThinImage[row][col] = 255;		  else if ((M2+M4+M6==3 && M3+M8+M9==0) || (M2+M4+M6==3 && M1+M7+M8==0) || (M8+M4+M6==3 && M1+M2+M7==0) || (M8+M4+M6==3 && M2+M3+M9==0) || (M2+M4+M8==3 && M6+M7+M9==0) || (M2+M4+M8==3 && M1+M3+M6==0) || (M2+M6+M8==3 && M1+M3+M4==0) || (M2+M6+M8==3 && M4+M7+M9==0))		    probeThinImage[row][col] = 255;		  else if ( (M1+M3==2 && M7+M8+M9>=1) || (M1+M7==2 && M3+M6+M9>=1) || (M7+M9==2 && M1+M2+M3>=1) || (M3+M9==2 && M1+M4+M7>=1) )		      probeThinImage[row][col] = 255;		  else if ( (M2+M6+M7==3 && M3+M4+M8==0) || (M2+M4+M9==3 && M1+M6+M8==0) || (M3+M4+M8==3 && M2+M6+M7==0) || (M1+M6+M8==3 && M2+M4+M9==0))		    probeThinImage[row][col] = 255;		  else{		    probeThinImage[row][col] = 0;		    change = true;		  }		}			      }	    }	  }	}while(false);	for (int row=0; row<Height_fly; row++){	  for (int col=0; col<Width_fly; col++){	    flyOutputImage[row][col] = flyThinImage[row][col];	  }	}	for (int row=0; row<Height_butterfly; row++){	  for (int col=0; col<Width_butterfly; col++){	    butterflyOutputImage[row][col] = butterflyThinImage[row][col];	  }	}	for (int row=0; row<Height_probe; row++){	  for (int col=0; col<Width_probe; col++){	    probeOutputImage[row][col] = probeThinImage[row][col];	  }	}	// SKELETONIZE	vector<vector <int> > butterflySkeletImage;	butterflySkeletImage.resize(Height_butterfly);	for (int row=0; row<Height_butterfly; row++)	  butterflySkeletImage[row].resize(Width_butterfly);	vector<vector <int> > flySkeletImage;	flySkeletImage.resize(Height_fly);	for (int row=0; row<Height_fly; row++)	  flySkeletImage[row].resize(Width_fly);	vector<vector <int> > probeSkeletImage;	probeSkeletImage.resize(Height_probe);	for (int row=0; row<Height_probe; row++)	  probeSkeletImage[row].resize(Width_probe);		do{	  	  bool change = true;	  vector<vector <int> > conM;	  conM.resize(Height_butterfly);	  for (int row=0; row<Height_butterfly; row++)	    conM[row].resize(Width_butterfly);	  	  for (int row=0; row<Height_butterfly; row++){	    for (int col=0; col<Width_butterfly; col++){	      butterflySkeletImage[row][col] = butterflyOutputImage[row][col];	    }	  }	  	  change = true;	  while (change){	    	    for (int row=0; row<Height_butterfly; row++){	      for (int col=0; col<Width_butterfly; col++){		  conM[row][col]=0;	      }	    }	    	    for (int row=1; row<Height_butterfly-1; row++){	      for (int col=1; col<Width_butterfly-1; col++){				if (butterflySkeletImage[row][col]==255){		  		  int M1 = butterflySkeletImage[row-1][col-1];		  int M2 = butterflySkeletImage[row-1][col];		  int M3 = butterflySkeletImage[row-1][col+1];		  int M4 = butterflySkeletImage[row][col-1];		  int M6 = butterflySkeletImage[row][col+1];		  int M7 = butterflySkeletImage[row+1][col-1];		  int M8 = butterflySkeletImage[row+1][col];		  int M9 = butterflySkeletImage[row+1][col+1];		  		  int bond = 0;		  		  if (M1==255)		    bond += 1;		  if (M2==255)		    bond += 2;		  if (M3==255)		      bond += 1;		  if (M4==255)		    bond += 2;		  if (M6==255)		    bond += 2;		  if (M7==255)		    bond += 1;		  if (M8==255)		    bond += 2;		  if (M9==255)		    bond += 1;		    		  if (bond==4 && ((M1==255 && M2==255 && M3==255) || (M3==255 && M6==255 && M9==255) || (M7==255 && M8==255 && M9==255) || (M1==255 && M4==255 && M7==255) || (M2+M6==255*2) || (M6+M8==255*2) || (M8+M4==255*2) || (M4+M2==255*2)))		    conM[row][col] = 1;		  		  if (bond==6 && ((M1==255 && M2==255 && M3==255 && M6==255) || (M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255) || (M1==255 && M2==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255) || (M4==255 && M7==255 && M8==255 && M9==255) || (M6==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==7 && ((M1==255 && M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M7==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==8 && ((M1==0 && M4==0 && M7==0) || (M1==0 && M2==0 && M3==0) || (M3==0 && M6==0 && M9==0) || (M7==0 && M8==0 && M9==0)))		    conM[row][col] = 1;		  		  if (bond==9 && ((M1==0 && M2==0) || (M2==0 && M3==0) || (M3==0 && M6==0) || (M6==0 && M9==0) || (M9==0 && M8==0) || (M8==0 && M7==0) || (M7==0 && M4==0) || (M4==0 && M1==0)))		    conM[row][col] = 1;		  		  if (bond==10 && (M2==0 || M4==0 || M6==0 || M8==0))		    conM[row][col] = 1;		  if (bond==11 && (M1==0 || M3==0 || M9==0 || M7==0))		    conM[row][col] = 1;		  		}	      }	    }	    	    change = false;	    // unconditional mark pattern application - stage 2	    for (int row=1; row<Height_butterfly-1; row++){	      for (int col=1; col<Width_butterfly-1; col++){				int M1 = conM[row-1][col-1];		int M2 = conM[row-1][col];		int M3 = conM[row-1][col+1];		int M4 = conM[row][col-1];		int M5 = conM[row][col];		int M6 = conM[row][col+1];		int M7 = conM[row+1][col-1];		int M8 = conM[row+1][col];		int M9 = conM[row+1][col+1];						if (M5==1){		  if ( (M1==1 && M2+M3+M4+M6+M7+M8+M9==0) || (M3==1 && M1+M2+M4+M6+M7+M8+M9==0))		    butterflySkeletImage[row][col] = 255;		  else if ( (M8==1 && M1+M2+M3+M4+M6+M7+M9==0) || (M6==1 && M1+M2+M3+M4+M7+M8+M9==0))		    butterflySkeletImage[row][col] = 255;		  else if ((M2+M6==2 && M1+M3+M4+M7+M8+M9==0) || (M8+M6==2 && M1+M2+M3+M4+M7+M9==0) || (M4+M8==2 && M1+M2+M3+M6+M7+M9==0) || (M2+M4==2 && M1+M3+M6+M7+M8+M9==0))		    butterflySkeletImage[row][col] = 255;		  else if (M1+M2+M4==3 || M6+M8+M9==3)		    butterflySkeletImage[row][col] = 255;		  else if (M2+M4+M6==3 || M8+M4+M6==3 || M2+M4+M8==3 || M2+M6+M8==3)		    butterflySkeletImage[row][col] = 255;		  else if ( (M1+M3==2 && M7+M8+M9>=1) || (M1+M7==2 && M3+M6+M9>=1) || (M7+M9==2 && M1+M2+M3>=1) || (M3+M9==2 && M1+M4+M7>=1) )		      butterflySkeletImage[row][col] = 255;		  else if ( (M2+M6+M7==3 && M3+M4+M8==0) || (M2+M4+M9==3 && M1+M6+M8==0) || (M3+M4+M8==3 && M2+M6+M7==0) || (M1+M6+M8==3 && M2+M4+M9==0))		    butterflySkeletImage[row][col] = 255;		  else{		    butterflySkeletImage[row][col] = 0;		    change = true;		  }		}			      }	    }	  }	}while(false);	// fly		do{	  	  bool change = true;	  vector<vector <int> > conM;	  conM.resize(Height_fly);	  for (int row=0; row<Height_fly; row++)	    conM[row].resize(Width_fly);	  	  for (int row=0; row<Height_fly; row++){	    for (int col=0; col<Width_fly; col++){	      flySkeletImage[row][col] = flyOutputImage[row][col];	    }	  }	  	  change = true;	  while (change){	    	    for (int row=0; row<Height_fly; row++){	      for (int col=0; col<Width_fly; col++){		  conM[row][col]=0;	      }	    }	    	    for (int row=1; row<Height_fly-1; row++){	      for (int col=1; col<Width_fly-1; col++){				if (flySkeletImage[row][col]==255){		  		  int M1 = flySkeletImage[row-1][col-1];		  int M2 = flySkeletImage[row-1][col];		  int M3 = flySkeletImage[row-1][col+1];		  int M4 = flySkeletImage[row][col-1];		  int M6 = flySkeletImage[row][col+1];		  int M7 = flySkeletImage[row+1][col-1];		  int M8 = flySkeletImage[row+1][col];		  int M9 = flySkeletImage[row+1][col+1];		  		  int bond = 0;		  		  if (M1==255)		    bond += 1;		  if (M2==255)		    bond += 2;		  if (M3==255)		      bond += 1;		  if (M4==255)		    bond += 2;		  if (M6==255)		    bond += 2;		  if (M7==255)		    bond += 1;		  if (M8==255)		    bond += 2;		  if (M9==255)		    bond += 1;		    		  if (bond==4 && ((M1==255 && M2==255 && M3==255) || (M3==255 && M6==255 && M9==255) || (M7==255 && M8==255 && M9==255) || (M1==255 && M4==255 && M7==255) || (M2+M6==255*2) || (M6+M8==255*2) || (M8+M4==255*2) || (M4+M2==255*2)))		    conM[row][col] = 1;		  		  if (bond==6 && ((M1==255 && M2==255 && M3==255 && M6==255) || (M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255) || (M1==255 && M2==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255) || (M4==255 && M7==255 && M8==255 && M9==255) || (M6==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==7 && ((M1==255 && M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M7==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==8 && ((M1==0 && M4==0 && M7==0) || (M1==0 && M2==0 && M3==0) || (M3==0 && M6==0 && M9==0) || (M7==0 && M8==0 && M9==0)))		    conM[row][col] = 1;		  		  if (bond==9 && ((M1==0 && M2==0) || (M2==0 && M3==0) || (M3==0 && M6==0) || (M6==0 && M9==0) || (M9==0 && M8==0) || (M8==0 && M7==0) || (M7==0 && M4==0) || (M4==0 && M1==0)))		    conM[row][col] = 1;		  		  if (bond==10 && (M2==0 || M4==0 || M6==0 || M8==0))		    conM[row][col] = 1;		  if (bond==11 && (M1==0 || M3==0 || M9==0 || M7==0))		    conM[row][col] = 1;		  		}	      }	    }	    	    change = false;	    // unconditional mark pattern application - stage 2	    for (int row=1; row<Height_fly-1; row++){	      for (int col=1; col<Width_fly-1; col++){				int M1 = conM[row-1][col-1];		int M2 = conM[row-1][col];		int M3 = conM[row-1][col+1];		int M4 = conM[row][col-1];		int M5 = conM[row][col];		int M6 = conM[row][col+1];		int M7 = conM[row+1][col-1];		int M8 = conM[row+1][col];		int M9 = conM[row+1][col+1];								if (M5==1){		  if ( (M1==1 && M2+M3+M4+M6+M7+M8+M9==0) || (M3==1 && M1+M2+M4+M6+M7+M8+M9==0))		    butterflySkeletImage[row][col] = 255;		  else if ( (M8==1 && M1+M2+M3+M4+M6+M7+M9==0) || (M6==1 && M1+M2+M3+M4+M7+M8+M9==0))		    butterflySkeletImage[row][col] = 255;		  else if ((M2+M6==2 && M1+M3+M4+M7+M8+M9==0) || (M8+M6==2 && M1+M2+M3+M4+M7+M9==0) || (M4+M8==2 && M1+M2+M3+M6+M7+M9==0) || (M2+M4==2 && M1+M3+M6+M7+M8+M9==0))		    butterflySkeletImage[row][col] = 255;		  else if (M1+M2+M4==3 || M6+M8+M9==3)		    butterflySkeletImage[row][col] = 255;		  else if (M2+M4+M6==3 || M8+M4+M6==3 || M2+M4+M8==3 || M2+M6+M8==3)		    butterflySkeletImage[row][col] = 255;		  else if ( (M1+M3==2 && M7+M8+M9>=1) || (M1+M7==2 && M3+M6+M9>=1) || (M7+M9==2 && M1+M2+M3>=1) || (M3+M9==2 && M1+M4+M7>=1) )		      butterflySkeletImage[row][col] = 255;		  else if ( (M2+M6+M7==3 && M3+M4+M8==0) || (M2+M4+M9==3 && M1+M6+M8==0) || (M3+M4+M8==3 && M2+M6+M7==0) || (M1+M6+M8==3 && M2+M4+M9==0))		    butterflySkeletImage[row][col] = 255;		  else{		    butterflySkeletImage[row][col] = 0;		    change = true;		  }		}			      }	    }	  }	}while(false);	// probe	do{	  	  bool change = true;	  vector<vector <int> > conM;	  conM.resize(Height_probe);	  for (int row=0; row<Height_probe; row++)	    conM[row].resize(Width_probe);	  	  for (int row=0; row<Height_probe; row++){	    for (int col=0; col<Width_probe; col++){	      probeSkeletImage[row][col] = probeOutputImage[row][col];	    }	  }	  	  change = true;	  while (change){	    	    for (int row=0; row<Height_probe; row++){	      for (int col=0; col<Width_probe; col++){		  conM[row][col]=0;	      }	    }	    	    for (int row=1; row<Height_probe-1; row++){	      for (int col=1; col<Width_probe-1; col++){				if (probeSkeletImage[row][col]==255){		  		  int M1 = probeSkeletImage[row-1][col-1];		  int M2 = probeSkeletImage[row-1][col];		  int M3 = probeSkeletImage[row-1][col+1];		  int M4 = probeSkeletImage[row][col-1];		  int M6 = probeSkeletImage[row][col+1];		  int M7 = probeSkeletImage[row+1][col-1];		  int M8 = probeSkeletImage[row+1][col];		  int M9 = probeSkeletImage[row+1][col+1];		  		  int bond = 0;		  		  if (M1==255)		    bond += 1;		  if (M2==255)		    bond += 2;		  if (M3==255)		      bond += 1;		  if (M4==255)		    bond += 2;		  if (M6==255)		    bond += 2;		  if (M7==255)		    bond += 1;		  if (M8==255)		    bond += 2;		  if (M9==255)		    bond += 1;		    		  if (bond==4 && ((M1==255 && M2==255 && M3==255) || (M3==255 && M6==255 && M9==255) || (M7==255 && M8==255 && M9==255) || (M1==255 && M4==255 && M7==255) || (M2+M6==255*2) || (M6+M8==255*2) || (M8+M4==255*2) || (M4+M2==255*2)))		    conM[row][col] = 1;		  		  if (bond==6 && ((M1==255 && M2==255 && M3==255 && M6==255) || (M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255) || (M1==255 && M2==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255) || (M4==255 && M7==255 && M8==255 && M9==255) || (M6==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==7 && ((M1==255 && M2==255 && M3==255 && M6==255 && M9==255) || (M1==255 && M2==255 && M3==255 && M4==255 && M7==255) || (M1==255 && M4==255 && M7==255 && M8==255 && M9==255) || (M3==255 && M6==255 && M7==255 && M8==255 && M9==255)))		    conM[row][col] = 1;		  		  if (bond==8 && ((M1==0 && M4==0 && M7==0) || (M1==0 && M2==0 && M3==0) || (M3==0 && M6==0 && M9==0) || (M7==0 && M8==0 && M9==0)))		    conM[row][col] = 1;		  		  if (bond==9 && ((M1==0 && M2==0) || (M2==0 && M3==0) || (M3==0 && M6==0) || (M6==0 && M9==0) || (M9==0 && M8==0) || (M8==0 && M7==0) || (M7==0 && M4==0) || (M4==0 && M1==0)))		    conM[row][col] = 1;		  		  if (bond==10 && (M2==0 || M4==0 || M6==0 || M8==0))		    conM[row][col] = 1;		  if (bond==11 && (M1==0 || M3==0 || M9==0 || M7==0))		    conM[row][col] = 1;		  		}	      }	    }	    	    change = false;	    // unconditional mark pattern application - stage 2	    for (int row=1; row<Height_probe-1; row++){	      for (int col=1; col<Width_probe-1; col++){				int M1 = conM[row-1][col-1];		int M2 = conM[row-1][col];		int M3 = conM[row-1][col+1];		int M4 = conM[row][col-1];		int M5 = conM[row][col];		int M6 = conM[row][col+1];		int M7 = conM[row+1][col-1];		int M8 = conM[row+1][col];		int M9 = conM[row+1][col+1];						if (M5==1){		  if ( (M1==1 && M2+M3+M4+M6+M7+M8+M9==0) || (M3==1 && M1+M2+M4+M6+M7+M8+M9==0))		    butterflySkeletImage[row][col] = 255;		  else if ( (M8==1 && M1+M2+M3+M4+M6+M7+M9==0) || (M6==1 && M1+M2+M3+M4+M7+M8+M9==0))		    butterflySkeletImage[row][col] = 255;		  else if ((M2+M6==2 && M1+M3+M4+M7+M8+M9==0) || (M8+M6==2 && M1+M2+M3+M4+M7+M9==0) || (M4+M8==2 && M1+M2+M3+M6+M7+M9==0) || (M2+M4==2 && M1+M3+M6+M7+M8+M9==0))		    butterflySkeletImage[row][col] = 255;		  else if (M1+M2+M4==3 || M6+M8+M9==3)		    butterflySkeletImage[row][col] = 255;		  else if (M2+M4+M6==3 || M8+M4+M6==3 || M2+M4+M8==3 || M2+M6+M8==3)		    butterflySkeletImage[row][col] = 255;		  else if ( (M1+M3==2 && M7+M8+M9>=1) || (M1+M7==2 && M3+M6+M9>=1) || (M7+M9==2 && M1+M2+M3>=1) || (M3+M9==2 && M1+M4+M7>=1) )		      butterflySkeletImage[row][col] = 255;		  else if ( (M2+M6+M7==3 && M3+M4+M8==0) || (M2+M4+M9==3 && M1+M6+M8==0) || (M3+M4+M8==3 && M2+M6+M7==0) || (M1+M6+M8==3 && M2+M4+M9==0))		    butterflySkeletImage[row][col] = 255;		  else{		    butterflySkeletImage[row][col] = 0;		    change = true;		  }		}			      }	    }	  }	}while(false);	// comment out if needed	// change output to show skeletonized images	for (int row=0; row<Height_fly; row++){	  for (int col=0; col<Width_fly; col++){	    flyOutputImage[row][col] = flySkeletImage[row][col];	  }	}	for (int row=0; row<Height_butterfly; row++){	  for (int col=0; col<Width_butterfly; col++){	    butterflyOutputImage[row][col] = butterflySkeletImage[row][col];	  }	}	for (int row=0; row<Height_probe; row++){	  for (int col=0; col<Width_probe; col++){	    probeOutputImage[row][col] = probeSkeletImage[row][col];	  }	}	// Count the number of intersections of 2 or more lines		int butterflyIntersection = 0;	int flyIntersection = 0;	int probeIntersection = 0;	for (int row=0; row<Height_butterfly; row++){	  for (int col=0; col<Width_butterfly; col++){	    if (butterflyOutputImage[row][col]==255){	      if (butterflyOutputImage[row-1][col-1]+butterflyOutputImage[row-1][col]+butterflyOutputImage[row-1][col+1]+butterflyOutputImage[row][col-1]+butterflyOutputImage[row][col+1]+butterflyOutputImage[row+1][col-1]+butterflyOutputImage[row+1][col]+butterflyOutputImage[row+1][col+1]>=765)		butterflyIntersection++;	    }	  }	}	for (int row=0; row<Height_fly; row++){	  for (int col=0; col<Width_fly; col++){	    if (flyOutputImage[row][col]==255){	      if (flyOutputImage[row-1][col-1]+flyOutputImage[row-1][col]+flyOutputImage[row-1][col+1]+flyOutputImage[row][col-1]+flyOutputImage[row][col+1]+flyOutputImage[row+1][col-1]+flyOutputImage[row+1][col]+flyOutputImage[row+1][col+1]>=765)		flyIntersection++;	    }	  }	}	for (int row=0; row<Height_probe; row++){	  for (int col=0; col<Width_probe; col++){	    if (probeOutputImage[row][col]==255){	      if (probeOutputImage[row-1][col-1]+probeOutputImage[row-1][col]+probeOutputImage[row-1][col+1]+probeOutputImage[row][col-1]+probeOutputImage[row][col+1]+probeOutputImage[row+1][col-1]+probeOutputImage[row+1][col]+probeOutputImage[row+1][col+1]>=765)		probeIntersection++;	    }	  }	}	cout << "Number of intersections in butterfly: " << butterflyIntersection << endl;	cout << "Number of intersections in fly: " << flyIntersection << endl;	cout << "Number of intersections in probe: " << probeIntersection << endl;	if (abs(butterflyIntersection-probeIntersection)<=abs(flyIntersection-probeIntersection))	  cout << "The probe is a butterfly" << endl;	else	  cout << "The probe is a fly" << endl;	  	// Write image data from image data matrix		if (!(file=fopen(argv[4],"wb"))) {	  cout << "Cannot open file: " << argv[2] << endl;	  exit(1);	}	fwrite(butterflyOutputImage, sizeof(unsigned char), Height_butterfly*Width_butterfly, file);	fclose(file);	if (!(file=fopen(argv[5],"wb"))) {	  cout << "Cannot open file: " << argv[2] << endl;	  exit(1);	}	fwrite(flyOutputImage, sizeof(unsigned char), Height_fly*Width_fly, file);	fclose(file);	if (!(file=fopen(argv[6],"wb"))) {	  cout << "Cannot open file: " << argv[2] << endl;	  exit(1);	}	fwrite(probeOutputImage, sizeof(unsigned char), Height_probe*Width_probe, file);	fclose(file);       		return 0;}