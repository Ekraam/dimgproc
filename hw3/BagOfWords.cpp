// Homework 3// This code implements Bag of words matching for SIFT features of images// Question 2c// This code takes no arguments// The image paths are hard coded here. change if needed.// //// Name: Ekraam Sabir // USC ID: 1428-2892-90// email: esabir@usc.edu// #include <opencv/cv.h>#include <opencv2/core/core.hpp>#include <opencv2/highgui/highgui.hpp>//#include <opencv2/features2d/features2d.hpp>#include <opencv2/nonfree/features2d.hpp>#include <opencv2/imgproc/imgproc.hpp>#include <fstream>#include <stdio.h>#include <iostream>#include <stdlib.h>#include <sstream>#define _USE_MATH_DEFINES#include <math.h>#include <cmath>#include <vector>#include <string>#include <algorithm>#include <limits.h>using namespace std;using namespace cv;int main(int argc, char *argv[]){  FILE *file;  // transfer Images to opencv  Mat rav4_1CVImg = imread("./HW3 Images/P2/rav4_1.jpg", CV_LOAD_IMAGE_UNCHANGED);  Mat rav4_2CVImg = imread("./HW3 Images/P2/rav4_2.jpg", CV_LOAD_IMAGE_UNCHANGED);  Mat jeepCVImg = imread("./HW3 Images/P2/jeep.jpg", CV_LOAD_IMAGE_UNCHANGED);  Mat busCVImg = imread("./HW3 Images/P2/bus.jpg", CV_LOAD_IMAGE_UNCHANGED);  // convert to grayscale  Mat rav4_1CVImg_gray;  Mat rav4_2CVImg_gray;  Mat jeepCVImg_gray;  Mat busCVImg_gray;  cvtColor(rav4_1CVImg, rav4_1CVImg_gray, CV_BGR2GRAY);  cvtColor(rav4_2CVImg, rav4_2CVImg_gray, CV_BGR2GRAY);  cvtColor(jeepCVImg, jeepCVImg_gray, CV_BGR2GRAY);  cvtColor(busCVImg, busCVImg_gray, CV_BGR2GRAY);  // SIFT  // get SIFT features  SiftFeatureDetector siftDetector;  vector<KeyPoint> rav4_1SiftKeypoints, rav4_2SiftKeypoints, jeepSiftKeypoints, busSiftKeypoints;  // detect keypoints  siftDetector.detect(rav4_1CVImg_gray, rav4_1SiftKeypoints);  siftDetector.detect(rav4_2CVImg_gray, rav4_2SiftKeypoints);  siftDetector.detect(jeepCVImg_gray, jeepSiftKeypoints);  siftDetector.detect(busCVImg_gray, busSiftKeypoints);  // get descriptors  SiftDescriptorExtractor siftExtractor;  Mat rav4_1SiftDescriptors, rav4_2SiftDescriptors, jeepSiftDescriptors, busSiftDescriptors;  siftExtractor.compute( rav4_1CVImg_gray, rav4_1SiftKeypoints, rav4_1SiftDescriptors );  siftExtractor.compute( rav4_2CVImg_gray, rav4_2SiftKeypoints, rav4_2SiftDescriptors );  siftExtractor.compute( jeepCVImg_gray, jeepSiftKeypoints, jeepSiftDescriptors );  siftExtractor.compute( busCVImg_gray, busSiftKeypoints, busSiftDescriptors );  // find number of descriptors in each  int descCount[3];  descCount[0] = rav4_1SiftDescriptors.rows;  descCount[1] = jeepSiftDescriptors.rows;  descCount[2] = busSiftDescriptors.rows;  // concatenate matrix  Mat data;  vconcat(rav4_1SiftDescriptors, jeepSiftDescriptors, data);  vconcat(data, busSiftDescriptors, data);  // k-means on the matrix  Mat centers;  Mat labels;  kmeans(data, 8, labels, TermCriteria(TermCriteria::EPS+TermCriteria::COUNT, 10000, 0.1), 3, KMEANS_PP_CENTERS, centers);  // get histogram of labels (image x bin)  int dataHist[3][8];  int base = 0;    for (int row=0; row<3; row++){    for (int bin=0; bin<8; bin++){      dataHist[row][bin] = 0;    }  }  for (int imgNum=0; imgNum<3; imgNum++){    for (int row=0; row<descCount[imgNum]; row++){      int bin = labels.at<int>(base+row,0);      dataHist[imgNum][bin] += 1;    }    base += descCount[imgNum];  }  // compute labels for target  int targHist[8] = {0, 0, 0, 0, 0, 0, 0, 0};  for (int i=0; i<rav4_2SiftDescriptors.rows; i++){        // get euclidean distance    Mat dummyMat;    for (int j=0; j<8; j++)      dummyMat.push_back(rav4_2SiftDescriptors.row(i));    dummyMat = dummyMat - centers;    pow(dummyMat, 2, dummyMat);    reduce(dummyMat, dummyMat, 1, CV_REDUCE_SUM);    sqrt(dummyMat, dummyMat);    // find bin with smallest distance    double min, max;    Point minPos, maxPos;    minMaxLoc(dummyMat, &min, &max, &minPos, &maxPos);        // add to bin    targHist[minPos.y]++;  }  // list of images  string ImageNames[3] = {"Rav4_1", "Jeep", "Bus"};      // compute target histogram similarity with data histograms using euclidian distance  int matchImg = 0;  float dist = INT_MAX;  for (int imgNum=0; imgNum<3; imgNum++){        float num = 0;    for (int i=0; i<8; i++){      num += pow(targHist[i]-dataHist[imgNum][i], 2);    }    num = sqrt(num);    if (num<dist){      dist = num;      matchImg = imgNum;    }  }  cout << "The codebook distributions/histogram " << endl;  for (int imgNum=0; imgNum<3; imgNum++){    cout << ImageNames[imgNum] << ": " << endl;    for (int col=0; col<8; col++){      cout << dataHist[imgNum][col] << " ";    }    cout << endl;  }  cout << "Distribution for query (Rav4_2) is" << endl;  for (int col=0; col<8; col++){    cout << targHist[col] << " ";  }  cout << endl;  cout << "The matching image found for Rav4_2 is " << ImageNames[matchImg] << " with an euclidian score of " << dist << " between histograms " << endl;  return 0;}