// Homework 3// This code implements SIFT and SURF feature matching// Question 2b// This code takes no arguments// The image paths are hardcoded here. change them if needed.// //// Name: Ekraam Sabir // USC ID: 1428-2892-90// email: esabir@usc.edu// #include <opencv/cv.h>#include <opencv2/core/core.hpp>#include <opencv2/highgui/highgui.hpp>#include <opencv2/nonfree/features2d.hpp>#include <opencv2/imgproc/imgproc.hpp>#include <fstream>#include <stdio.h>#include <iostream>#include <stdlib.h>#include <sstream>#define _USE_MATH_DEFINES#include <math.h>#include <cmath>#include <vector>#include <string>#include <algorithm>#include <limits.h>using namespace std;using namespace cv;int main(int argc, char *argv[]){  FILE *file;  // transfer Images to opencv  Mat rav4_1CVImg = imread("./HW3 Images/P2/rav4_1.jpg", CV_LOAD_IMAGE_UNCHANGED);  Mat rav4_2CVImg = imread("./HW3 Images/P2/rav4_2.jpg", CV_LOAD_IMAGE_UNCHANGED);  Mat jeepCVImg = imread("./HW3 Images/P2/jeep.jpg", CV_LOAD_IMAGE_UNCHANGED);  Mat busCVImg = imread("./HW3 Images/P2/bus.jpg", CV_LOAD_IMAGE_UNCHANGED);  // convert to grayscale  Mat rav4_1CVImg_gray;  Mat rav4_2CVImg_gray;  Mat jeepCVImg_gray;  Mat busCVImg_gray;  cvtColor(rav4_1CVImg, rav4_1CVImg_gray, CV_BGR2GRAY);  cvtColor(rav4_2CVImg, rav4_2CVImg_gray, CV_BGR2GRAY);  cvtColor(jeepCVImg, jeepCVImg_gray, CV_BGR2GRAY);  cvtColor(busCVImg, busCVImg_gray, CV_BGR2GRAY);  // SIFT  // get SIFT features  SiftFeatureDetector siftDetector;  vector<KeyPoint> rav4_1SiftKeypoints, rav4_2SiftKeypoints, jeepSiftKeypoints, busSiftKeypoints;  // detect keypoints  siftDetector.detect(rav4_1CVImg_gray, rav4_1SiftKeypoints);  siftDetector.detect(rav4_2CVImg_gray, rav4_2SiftKeypoints);  siftDetector.detect(jeepCVImg_gray, jeepSiftKeypoints);  siftDetector.detect(busCVImg_gray, busSiftKeypoints);  // get descriptors  SiftDescriptorExtractor siftExtractor;  Mat rav4_1SiftDescriptors, rav4_2SiftDescriptors, jeepSiftDescriptors, busSiftDescriptors;  siftExtractor.compute( rav4_1CVImg_gray, rav4_1SiftKeypoints, rav4_1SiftDescriptors );  siftExtractor.compute( rav4_2CVImg_gray, rav4_2SiftKeypoints, rav4_2SiftDescriptors );  siftExtractor.compute( jeepCVImg_gray, jeepSiftKeypoints, jeepSiftDescriptors );  siftExtractor.compute( busCVImg_gray, busSiftKeypoints, busSiftDescriptors );  // matching of descriptors  FlannBasedMatcher siftMatcher;  vector<vector< DMatch > > siftMatches_rav4_1_rav4_2, siftMatches_rav4_1_jeep, siftMatches_rav4_1_bus;  siftMatcher.knnMatch( rav4_1SiftDescriptors, rav4_2SiftDescriptors, siftMatches_rav4_1_rav4_2, 2);  siftMatcher.knnMatch( rav4_1SiftDescriptors, jeepSiftDescriptors, siftMatches_rav4_1_jeep, 2);  siftMatcher.knnMatch( rav4_1SiftDescriptors, busSiftDescriptors, siftMatches_rav4_1_bus, 2);  // Sift matching setup for rav4_1 and rav4_2  /*  double maxDist = 0; double minDist = 100;  // get min and max distance  for( int i = 0; i < rav4_1SiftDescriptors.rows; i++ ){    double dist = siftMatches_rav4_1_rav4_2[i].distance;    if( dist < minDist )      minDist = dist;    if( dist > maxDist )      maxDist = dist;  }  cout << "Max distance " << maxDist << endl;  cout << "Min distance " << minDist << endl;  */  // find good matches  vector< DMatch > goodSiftMatches_rav4_1_rav4_2;  /*  for( int i = 0; i < rav4_1SiftDescriptors.rows; i++ ){    if( siftMatches_rav4_1_rav4_2[i].distance <= 2*minDist ){      goodSiftMatches_rav4_1_rav4_2.push_back( siftMatches_rav4_1_rav4_2[i]);    }  }  */  for (int i=0; i<siftMatches_rav4_1_rav4_2.size(); i++){    if (siftMatches_rav4_1_rav4_2[i][0].distance<0.8*siftMatches_rav4_1_rav4_2[i][1].distance){      goodSiftMatches_rav4_1_rav4_2.push_back(siftMatches_rav4_1_rav4_2[i][0]);    }  }  // Draw the good matches  Mat rav4_1_SiftMatch_rav4_2;  drawMatches( rav4_1CVImg_gray, rav4_1SiftKeypoints, rav4_2CVImg_gray, rav4_2SiftKeypoints,               goodSiftMatches_rav4_1_rav4_2, rav4_1_SiftMatch_rav4_2, Scalar::all(-1), Scalar::all(-1),               vector<char>());//, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );  // Show matched matches  namedWindow("rav4_1 and rav4_2 matched SIFT features", CV_WINDOW_AUTOSIZE);   imshow( "rav4_1 and rav4_2 matched SIFT features", rav4_1_SiftMatch_rav4_2 );  waitKey(0);  // Sift matching setup for rav4_1 and jeep  /*  maxDist = 0; minDist = 100;  // get min and max distance  for( int i = 0; i < rav4_1SiftDescriptors.rows; i++ ){    double dist = siftMatches_rav4_1_jeep[i].distance;    if( dist < minDist )      minDist = dist;    if( dist > maxDist )      maxDist = dist;  }  cout << "Max distance " << maxDist << endl;  cout << "Min distance " << minDist << endl;  */  // find good matches  vector< DMatch > goodSiftMatches_rav4_1_jeep;  /*  for( int i = 0; i < rav4_1SiftDescriptors.rows; i++ ){    if( siftMatches_rav4_1_jeep[i].distance <= 2*minDist ){      goodSiftMatches_rav4_1_jeep.push_back( siftMatches_rav4_1_jeep[i]);    }  }  */  for (int i=0; i<siftMatches_rav4_1_jeep.size(); i++){    if (siftMatches_rav4_1_jeep[i][0].distance<0.8*siftMatches_rav4_1_jeep[i][1].distance){      goodSiftMatches_rav4_1_jeep.push_back(siftMatches_rav4_1_jeep[i][0]);    }  }  // Draw the good matches  Mat rav4_1_SiftMatch_jeep;  drawMatches( rav4_1CVImg_gray, rav4_1SiftKeypoints, jeepCVImg_gray, jeepSiftKeypoints,               goodSiftMatches_rav4_1_jeep, rav4_1_SiftMatch_jeep, Scalar::all(-1), Scalar::all(-1),               vector<char>());//, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );  // Show matched matches  namedWindow("rav4_1 and jeep matched SIFT features", CV_WINDOW_AUTOSIZE);   imshow( "rav4_1 and jeep matched SIFT features", rav4_1_SiftMatch_jeep );  waitKey(0);  // Sift matching setup for rav4_1 and bus  /*  maxDist = 0; minDist = 100;  // get min and max distance  for( int i = 0; i < rav4_1SiftDescriptors.rows; i++ ){    double dist = siftMatches_rav4_1_bus[i].distance;    if( dist < minDist )      minDist = dist;    if( dist > maxDist )      maxDist = dist;  }  cout << "Max distance " << maxDist << endl;  cout << "Min distance " << minDist << endl;  */  // find good matches  vector< DMatch > goodSiftMatches_rav4_1_bus;  /*  for( int i = 0; i < rav4_1SiftDescriptors.rows; i++ ){    if( siftMatches_rav4_1_bus[i].distance <= 2*minDist ){      goodSiftMatches_rav4_1_bus.push_back( siftMatches_rav4_1_bus[i]);    }  }  */  for (int i=0; i<siftMatches_rav4_1_bus.size(); i++){    if (siftMatches_rav4_1_bus[i][0].distance<0.8*siftMatches_rav4_1_bus[i][1].distance){      goodSiftMatches_rav4_1_bus.push_back(siftMatches_rav4_1_bus[i][0]);    }  }  // Draw the good matches  Mat rav4_1_SiftMatch_bus;  drawMatches( rav4_1CVImg_gray, rav4_1SiftKeypoints, busCVImg_gray, busSiftKeypoints,               goodSiftMatches_rav4_1_bus, rav4_1_SiftMatch_bus, Scalar::all(-1), Scalar::all(-1),               vector<char>());//, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );  // Show matched matches  namedWindow("rav4_1 and bus matched SIFT features", CV_WINDOW_AUTOSIZE);   imshow( "rav4_1 and bus matched SIFT features", rav4_1_SiftMatch_bus );  waitKey(0);  // SURF  // get SURF features  // detect keypoints  int threshold = 3000;  SurfFeatureDetector surfDetector(threshold);  vector<KeyPoint> rav4_1SurfKeypoints, rav4_2SurfKeypoints, jeepSurfKeypoints, busSurfKeypoints;  surfDetector.detect(rav4_1CVImg_gray, rav4_1SurfKeypoints);  surfDetector.detect(rav4_2CVImg_gray, rav4_2SurfKeypoints);  surfDetector.detect(jeepCVImg_gray, jeepSurfKeypoints);  surfDetector.detect(busCVImg_gray, busSurfKeypoints);  // get descriptors  SurfDescriptorExtractor surfExtractor;  Mat rav4_1SurfDescriptors, rav4_2SurfDescriptors, jeepSurfDescriptors, busSurfDescriptors;  surfExtractor.compute( rav4_1CVImg_gray, rav4_1SurfKeypoints, rav4_1SurfDescriptors );  surfExtractor.compute( rav4_2CVImg_gray, rav4_2SurfKeypoints, rav4_2SurfDescriptors );  surfExtractor.compute( jeepCVImg_gray, jeepSurfKeypoints, jeepSurfDescriptors );  surfExtractor.compute( busCVImg_gray, busSurfKeypoints, busSurfDescriptors );  // matching of descriptors  FlannBasedMatcher surfMatcher;  vector<vector< DMatch > > surfMatches_rav4_1_rav4_2, surfMatches_rav4_1_jeep, surfMatches_rav4_1_bus;  surfMatcher.knnMatch( rav4_1SurfDescriptors, rav4_2SurfDescriptors, surfMatches_rav4_1_rav4_2, 2);  surfMatcher.knnMatch( rav4_1SurfDescriptors, jeepSurfDescriptors, surfMatches_rav4_1_jeep, 2);  surfMatcher.knnMatch( rav4_1SurfDescriptors, busSurfDescriptors, surfMatches_rav4_1_bus, 2);  // Surf matching setup for rav4_1 and rav4_2  /*  maxDist = 0; minDist = 100;  // get min and max distance  for( int i = 0; i < rav4_1SurfDescriptors.rows; i++ ){    double dist = surfMatches_rav4_1_rav4_2[i].distance;    if( dist < minDist )      minDist = dist;    if( dist > maxDist )      maxDist = dist;  }  cout << "Max distance " << maxDist << endl;  cout << "Min distance " << minDist << endl;  */  // find good matches  vector< DMatch > goodSurfMatches_rav4_1_rav4_2;  /*  for( int i = 0; i < rav4_1SurfDescriptors.rows; i++ ){    if( surfMatches_rav4_1_rav4_2[i].distance <= 1.5*minDist ){      goodSurfMatches_rav4_1_rav4_2.push_back( surfMatches_rav4_1_rav4_2[i]);    }  }  */  for (int i=0; i<surfMatches_rav4_1_rav4_2.size(); i++){    if (surfMatches_rav4_1_rav4_2[i][0].distance<0.8*surfMatches_rav4_1_rav4_2[i][1].distance){      goodSurfMatches_rav4_1_rav4_2.push_back(surfMatches_rav4_1_rav4_2[i][0]);    }  }  // Draw the good matches  Mat rav4_1_SurfMatch_rav4_2;  drawMatches( rav4_1CVImg_gray, rav4_1SurfKeypoints, rav4_2CVImg_gray, rav4_2SurfKeypoints,               goodSurfMatches_rav4_1_rav4_2, rav4_1_SurfMatch_rav4_2, Scalar::all(-1), Scalar::all(-1),               vector<char>());//, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );  // Show matched matches  namedWindow("rav4_1 and rav4_2 matched SURF features", CV_WINDOW_AUTOSIZE);   imshow( "rav4_1 and rav4_2 matched SURF features", rav4_1_SurfMatch_rav4_2 );  waitKey(0);  // Surf matching setup for rav4_1 and jeep  /*  maxDist = 0; minDist = 100;  // get min and max distance  for( int i = 0; i < rav4_1SurfDescriptors.rows; i++ ){    double dist = surfMatches_rav4_1_jeep[i].distance;    if( dist < minDist )      minDist = dist;    if( dist > maxDist )      maxDist = dist;  }  cout << "Max distance " << maxDist << endl;  cout << "Min distance " << minDist << endl;  */  // find good matches  vector< DMatch > goodSurfMatches_rav4_1_jeep;  /*  for( int i = 0; i < rav4_1SurfDescriptors.rows; i++ ){    if( surfMatches_rav4_1_jeep[i].distance <= 1.5*minDist ){      goodSurfMatches_rav4_1_jeep.push_back( surfMatches_rav4_1_jeep[i]);    }  }  */  for (int i=0; i<surfMatches_rav4_1_jeep.size(); i++){    if (surfMatches_rav4_1_jeep[i][0].distance<0.8*surfMatches_rav4_1_jeep[i][1].distance){      goodSurfMatches_rav4_1_jeep.push_back(surfMatches_rav4_1_jeep[i][0]);    }  }  // Draw the good matches  Mat rav4_1_SurfMatch_jeep;  drawMatches( rav4_1CVImg_gray, rav4_1SurfKeypoints, jeepCVImg_gray, jeepSurfKeypoints,               goodSurfMatches_rav4_1_jeep, rav4_1_SurfMatch_jeep, Scalar::all(-1), Scalar::all(-1),               vector<char>());//, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );  // Show matched matches  namedWindow("rav4_1 and jeep matched SURF features", CV_WINDOW_AUTOSIZE);   imshow( "rav4_1 and jeep matched SURF features", rav4_1_SurfMatch_jeep );  waitKey(0);  // Surf matching setup for rav4_1 and bus  /*  maxDist = 0; minDist = 100;    // get min and max distance  for( int i = 0; i < rav4_1SurfDescriptors.rows; i++ ){    double dist = surfMatches_rav4_1_bus[i].distance;    if( dist < minDist )      minDist = dist;    if( dist > maxDist )      maxDist = dist;  }  cout << "Max distance " << maxDist << endl;  cout << "Min distance " << minDist << endl;  */  // find good matches  vector< DMatch > goodSurfMatches_rav4_1_bus;  /*  for( int i = 0; i < rav4_1SurfDescriptors.rows; i++ ){    if( surfMatches_rav4_1_bus[i].distance <= 1.5*minDist ){      goodSurfMatches_rav4_1_bus.push_back( surfMatches_rav4_1_bus[i]);    }  }  */  for (int i=0; i<surfMatches_rav4_1_bus.size(); i++){    if (surfMatches_rav4_1_bus[i][0].distance<0.8*surfMatches_rav4_1_bus[i][1].distance){      goodSurfMatches_rav4_1_bus.push_back(surfMatches_rav4_1_bus[i][0]);    }  }  // Draw the good matches  Mat rav4_1_SurfMatch_bus;  drawMatches( rav4_1CVImg_gray, rav4_1SurfKeypoints, busCVImg_gray, busSurfKeypoints,               goodSurfMatches_rav4_1_bus, rav4_1_SurfMatch_bus, Scalar::all(-1), Scalar::all(-1),               vector<char>());//, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );  // Show matched matches  namedWindow("rav4_1 and bus matched SURF features", CV_WINDOW_AUTOSIZE);   imshow( "rav4_1 and bus matched SURF features", rav4_1_SurfMatch_bus );  waitKey(0);    return 0;}