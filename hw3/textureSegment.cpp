// Homework 3// This code implements // Question // This code takes 11 arguments in the following format// program_name input_image.raw logo_image.raw output_image.raw [BytesPerPixel = 1] [Width = 256] [Height = 256] [BytesPerPixel_Logo = 1] [Width_Logo = 256] [Height_Logo = 256] [background = 1]// //// Name: Ekraam Sabir // USC ID: 1428-2892-90// email: esabir@usc.edu// #include <opencv2/core/core.hpp>#include <opencv2/highgui/highgui.hpp>#include <fstream>#include <stdio.h>#include <iostream>#include <stdlib.h>#include <sstream>#define _USE_MATH_DEFINES#include <math.h>#include <cmath>#include <vector>#include <string>#include <algorithm>#include <limits.h>using namespace std;using namespace cv;extern int *k_means(double**, int, int, int, double, double**);double** getEnergyImg(int filt1[5], int filt2[5], int** img, int extraWin, int Height, int Width){  int filt[5][5];  // compute the coefficients of the filters  int coeff1 = 0;  int coeff2 = 0;  for (int i=0; i<5; i++){    coeff1 += filt1[i];    coeff2 += filt2[i];  }  int coeff = (coeff1+2)*(coeff2+2);  // muiltiply both the filters to get the 2d filter filt1'*filt2  for (int row=0; row<5; row++){    for (int col=0; col<5; col++){      filt[row][col] = filt1[row]*filt2[col];    }  }  // get the DC component (mean) of the image  double DC = 0;  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      DC += img[row+2][col+2];    }  }  DC = DC/(Height*Width);  // energy response image  double** Energy = new double*[Height];  for (int i=0; i<Height; i++){    Energy[i] = new double[Width];  }  // initialize the Energy matrix  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      Energy[row][col] = 0;    }  }  cout << "before filling" << endl;    // fill the energy matrix with values  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      double avgEnergy = 0;      int winCount = 0;      // convolve over window      for (int wrow=row+2; wrow<Height+2*extraWin-2; wrow++){	for (int wcol=col+2; wcol<col+2*extraWin-2; wcol++){	        	  winCount++;	  // multiply each filter after subtracting DC component	  for (int i=0; i<5; i++){	    for (int j=0; j<5; j++){	      avgEnergy += filt[i][j]*(img[wrow-2+i][wcol-2+j]-DC)*(1/coeff);	      //cout << "row "<< row << "col " << col << "wrow " << wrow << "wcol " << wcol << "i " << i << " j " << j << endl;	    }	  }	}      }      avgEnergy /= winCount;      Energy[row][col] = avgEnergy;    }  }  cout << "after filling " << endl;  return Energy;}double*** getEnergyMap(int** img, int extraWin, int Height, int Width){  int L[5] = {1, 4, 6, 4, 1};  int E[5] = {-1, -2, 0, 2, 1};  int S[5] = {-1, 0, 2, 0, -1};  int W[5] = {-1, 2, 0, -2, 1};  int R[5] = {1, -4, 6, -4, 1};  int** filtbank = new int*[5];  for (int i=0; i<5; i++){    filtbank[i] = new int[5];  }  filtbank[0] = L;  filtbank[1] = E;  filtbank[2] = S;  filtbank[3] = W;  filtbank[4] = R;  double*** EnergyMap = new double**[Height];  for (int row=0; row<Height; row++){    EnergyMap[row] = new double*[Width];    for (int col=0; col<Width; col++){      EnergyMap[row][col] = new double[25];    }  }   int counter = 0;  double** dummyEnergy;  for (int i=0; i<5; i++){    for (int j=0; j<5; j++){      cout << counter << endl;      dummyEnergy = getEnergyImg(filtbank[i], filtbank[j], img, extraWin, Height, Width);            // store the energy images in EnergyMap      for (int row=0; row<Height; row++){	for(int col=0; col<Width; col++){	  EnergyMap[row][col][counter] = dummyEnergy[row][col];	}      }      counter++;    }  }  delete [] filtbank;  return EnergyMap;}int main(int argc, char *argv[]){  FILE *file;  int winSize = 13;    // Allocate image data array  unsigned char tempImage[500][425];  int** Comb1 = new int*[500+winSize-1];  for (int i=0; i<500+winSize-1; i++){    Comb1[i] = new int[425+winSize-1];  }  int** Comb2 = new int*[512+winSize-1];  for (int i=0; i<512+winSize-1; i++){    Comb2[i] = new int[512+winSize-1];  }  // Allocate feature Matrix  /*  double** eVec25 = new double*[12];  for (int i=0; i<12; i++){    eVec25[i] = new double[25];  }  */  // array of image names  string basename = "./HW3 Images/P1/Texture";  string extension = ".raw";  ///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////    // Read Image into image data matrix  if (!(file=fopen("./HW3 Images/P1/Comb_1.raw","rb"))) {    cout << "Cannot open file: " << "./HW3 Images/P1/Comb_1.raw" << endl;    exit(1);  }  fread(tempImage, sizeof(unsigned char), 500*425, file);  fclose(file);  int extraWin = (int)winSize/2;  cout << "winSize " << (int)winSize/2 << endl;  for (int row=0; row<500; row++){    for (int col=0; col<425; col++){      Comb1[row+extraWin][col+extraWin] = (int)tempImage[row][col];    }  }      // pad elements to edges  // rows  for (int i=0; i<extraWin; i++){    for(int col=0; col<425; col++){      Comb1[i][col+extraWin] = Comb1[extraWin*2-1-i][col+extraWin];    }  }  for (int i=500+extraWin; i<500+extraWin*2; i++){    for(int col=0; col<425; col++){      Comb1[i][col+extraWin] = Comb1[-i+500+extraWin+500+extraWin-1][col+extraWin];    }  }        // cols  for (int j=0; j<extraWin; j++){    for (int row=0; row<500; row++){      Comb1[row+extraWin][j] = Comb1[row+extraWin][-j+extraWin*2-1];    }  }  for (int j=425+extraWin; j<425+extraWin*2; j++){    for (int row=0; row<500; row++){      Comb1[row+extraWin][j] = Comb1[row+extraWin][-j+425+extraWin+425+extraWin-1];    }  }  /*    // corners    texture1[0][0] = texture1[3][3];    texture1[1][1] = texture1[2][2];    texture1[0][1] = texture1[2][3];    texture1[1][0] = texture1[3][2];        texture1[0][130] = texture1[2][128];    texture1[0][131] = texture1[3][128];    texture1[1][130] = texture1[2][129];    texture1[1][131] = texture1[3][129];        texture1[130][130] = texture1[129][129];    texture1[130][131] = texture1[128][129];    texture1[131][131] = texture1[128][128];    texture1[131][130] = texture1[129][128];        texture1[130][0] = texture1[128][2];    texture1[130][1] = texture1[129][2];    texture1[131][0] = texture1[128][3];    texture1[131][1] = texture1[129][3];  */      double*** EnergyMap;  EnergyMap = getEnergyMap(Comb1, extraWin, 500, 425);  // create data points matrix  double** eVec25 = new double*[500*425];  for (int row=0; row<500*425; row++){    eVec25[row] = new double[25];  }  int counter=0;  for (int row=0; row<500; row++){    for (int col=0; col<425; col++){      for (int featDim=0; featDim<25; featDim++){	eVec25[counter][featDim] = EnergyMap[row][col][featDim];      }    }  }  // normalize the values with LL filter values  for (int row=0; row<25; row++){    double divVal = eVec25[row][0];    for (int col=0; col<25; col++){      eVec25[row][col] /= divVal;    }  }  /*  // pca using opencv  double norm_eVec[12][25];  for (int row=0; row<12; row++){    for (int col=0; col<25; col++){      norm_eVec[row][col] = eVec25[row][col];    }  }  Mat cv_eVec25 = Mat(12, 25, CV_64F, norm_eVec);  PCA pca(cv_eVec25, Mat(), CV_PCA_DATA_AS_ROW, 3);    Mat proj_eVec3 = Mat::zeros(12, 3, CV_32F);    pca.project(cv_eVec25, proj_eVec3);  cout << "Projected vectors into 3D space " << endl;  cout << proj_eVec3 << endl;  // transfer the feature vectors to c++ matrix  double** eVec3 = new double*[12];  for (int row=0; row<12; row++){    eVec3[row] = new double[3];  }    for (int row=0; row<12; row++){    for (int col=0; col<3; col++){      eVec3[row][col] = proj_eVec3.at<double>(row,col);    }  }  */  // K-means  // 25-D vectors  int* class_25D = k_means(eVec25, 500*425, 25, 4, 0.0001, 0);  // output image  int grayLevels[4] = {0, 64, 128, 255};  unsigned char Comb1Segment[500][425];  counter=0;  for (int row=0; row<500; row++){    for (int col=0; col<425; col++){      Comb1Segment[row][col] = (unsigned char)grayLevels[class_25D[counter]];    }  }  if (!(file=fopen("Comb1Segment.raw","wb"))) {    cout << "Cannot open file: " << "Comb1Segment.raw" << endl;    exit(1);  }  fwrite(Comb1Segment, sizeof(unsigned char), 500*425, file);  fclose(file);  // clear memory  /*  for (int i=0; i<128; i++){    delete [] texture1[i];  }  delete [] texture1;  */    return 0;}