// Homework 3// This code implements texture Segmentation// Question 1b// This code takes no arguments// The image paths are hard coded. change them here inside the script// //// Name: Ekraam Sabir // USC ID: 1428-2892-90// email: esabir@usc.edu// #include <opencv2/core/core.hpp>#include <opencv2/highgui/highgui.hpp>#include <fstream>#include <stdio.h>#include <iostream>#include <stdlib.h>#include <sstream>#define _USE_MATH_DEFINES#include <math.h>#include <cmath>#include <vector>#include <string>#include <algorithm>#include <limits.h>using namespace std;using namespace cv;extern int *k_means(double**, int, int, int, double, double**);double** getEnergyImg(int filt1[5], int filt2[5], int** img, int extraWin, int Height, int Width){  int filt[5][5];  // compute the coefficients of the filters  int coeff1 = 0;  int coeff2 = 0;  for (int i=0; i<5; i++){    coeff1 += filt1[i];    coeff2 += filt2[i];  }  int coeff = (coeff1+2)*(coeff2+2);  // muiltiply both the filters to get the 2d filter filt1'*filt2  for (int row=0; row<5; row++){    for (int col=0; col<5; col++){      filt[row][col] = filt1[row]*filt2[col];    }  }  // get the DC component (mean) of the image  double DC = 0;  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      DC += img[row+2][col+2];    }  }  DC = DC/(Height*Width);  // energy response image  double** Energy = new double*[Height];  for (int i=0; i<Height; i++){    Energy[i] = new double[Width];  }  // initialize the Energy matrix  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      Energy[row][col] = 0;    }  }    // fill the energy matrix with values  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      double avgEnergy = 0;      int winCount = 0;      // convolve over window      for (int wrow=row+2; wrow<Height+2*extraWin-2; wrow++){	for (int wcol=col+2; wcol<col+2*extraWin-2; wcol++){	        	  winCount++;	  // multiply each filter after subtracting DC component	  for (int i=0; i<5; i++){	    for (int j=0; j<5; j++){	      avgEnergy += pow(filt[i][j]*(img[wrow-2+i][wcol-2+j]-DC)*(1.0/coeff),2);	    }	  }	}      }      avgEnergy /= winCount;      Energy[row][col] = avgEnergy;    }  }  return Energy;}double*** getEnergyMap(int** img, int extraWin, int Height, int Width){  int L[5] = {1, 4, 6, 4, 1};  int E[5] = {-1, -2, 0, 2, 1};  int S[5] = {-1, 0, 2, 0, -1};  int W[5] = {-1, 2, 0, -2, 1};  int R[5] = {1, -4, 6, -4, 1};  int** filtbank = new int*[5];  for (int i=0; i<5; i++){    filtbank[i] = new int[5];  }  filtbank[0] = L;  filtbank[1] = E;  filtbank[2] = S;  filtbank[3] = W;  filtbank[4] = R;  double*** EnergyMap = new double**[Height];  for (int row=0; row<Height; row++){    EnergyMap[row] = new double*[Width];    for (int col=0; col<Width; col++){      EnergyMap[row][col] = new double[25];    }  }   int counter = 0;  double** dummyEnergy;  for (int i=0; i<5; i++){    for (int j=0; j<5; j++){      cout << "filter: " << counter << endl;      dummyEnergy = getEnergyImg(filtbank[i], filtbank[j], img, extraWin, Height, Width);            // store the energy images in EnergyMap      for (int row=0; row<Height; row++){	for(int col=0; col<Width; col++){	  EnergyMap[row][col][counter] = dummyEnergy[row][col];	}      }      counter++;    }  }  delete [] filtbank;  return EnergyMap;}int main(int argc, char *argv[]){  FILE *file;  int winSize = 13;    // Allocate image data array  unsigned char tempImage[500][425];  int** Comb1 = new int*[500+winSize-1];  for (int i=0; i<500+winSize-1; i++){    Comb1[i] = new int[425+winSize-1];  }  int** Comb2 = new int*[512+winSize-1];  for (int i=0; i<512+winSize-1; i++){    Comb2[i] = new int[512+winSize-1];  }  ///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////  /*    int Height = 500;  int Width = 425;  // Read Image into image data matrix  if (!(file=fopen("./HW3 Images/P1/Comb_1.raw","rb"))) {    cout << "Cannot open file: " << "./HW3 Images/P1/Comb_1.raw" << endl;    exit(1);  }  fread(tempImage, sizeof(unsigned char), Height*Width, file);  fclose(file);  int extraWin = (int)winSize/2;  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      Comb1[row+extraWin][col+extraWin] = (int)tempImage[row][col];    }  }      // pad elements to edges  // rows  for (int i=0; i<extraWin; i++){    for(int col=0; col<Width; col++){      Comb1[i][col+extraWin] = Comb1[extraWin*2-1-i][col+extraWin];    }  }  for (int i=Height+extraWin; i<Height+extraWin*2; i++){    for(int col=0; col<Width; col++){      Comb1[i][col+extraWin] = Comb1[-i+Height+extraWin+Height+extraWin-1][col+extraWin];    }  }        // cols  for (int j=0; j<extraWin; j++){    for (int row=0; row<Height; row++){      Comb1[row+extraWin][j] = Comb1[row+extraWin][-j+extraWin*2-1];    }  }  for (int j=Width+extraWin; j<Width+extraWin*2; j++){    for (int row=0; row<Height; row++){      Comb1[row+extraWin][j] = Comb1[row+extraWin][-j+Width+extraWin+Width+extraWin-1];    }  }  // corners  for (int row=0; row<extraWin; row++){    for (int col=0; col<extraWin; col++){      Comb1[row][col] = Comb1[row+extraWin][col+extraWin];    }  }    for (int row=0; row<extraWin; row++){    for (int col=Width+extraWin; col<Width+2*extraWin; col++){      Comb1[row][col] = Comb1[row][col-extraWin];    }  }    for (int row=Height+extraWin; row<Height+2*extraWin; row++){    for (int col=Width+extraWin; col<Width+2*extraWin; col++){      Comb1[row][col] = Comb1[row-extraWin][col-extraWin];    }  }  for (int row=Height+extraWin; row<Height+2*extraWin; row++){    for (int col=0; col<extraWin; col++){      Comb1[row][col] = Comb1[row-extraWin][col];    }  }      double*** EnergyMap;  EnergyMap = getEnergyMap(Comb1, extraWin, Height, Width);  // create data points matrix  double** eVec25 = new double*[Height*Width];  for (int row=0; row<Height*Width; row++){    eVec25[row] = new double[25];  }  int counter=0;  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      for (int featDim=0; featDim<25; featDim++){	eVec25[counter][featDim] = EnergyMap[row][col][featDim];      }      counter++;    }  }  // normalize the values with LL filter values  double divVal = 0;  for (int row=0; row<Height*Width; row++){    divVal += eVec25[row][0];  }  divVal /= (Height*Width);  for (int row=0; row<Height*Width; row++){    for (int col=0; col<25; col++){      eVec25[row][col] /= divVal;    }  }  // K-means  // 25-D vectors  int* class_25D = k_means(eVec25, Height*Width, 25, 4, 0.0001, 0);  for (int row=0; row<Height*Width; row++){    cout << class_25D[row] << " ";  }  cout << endl;  // output image  int grayLevels[4] = {0, 64, 128, 255};  unsigned char Comb1Segment[Height][Width];  counter=0;  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      Comb1Segment[row][col] = (unsigned char)grayLevels[class_25D[counter]];      counter++;      cout << Comb1Segment[row][col] << " ";    }    cout << endl;  }  if (!(file=fopen("Comb1Segment.raw","wb"))) {    cout << "Cannot open file: " << "Comb1Segment.raw" << endl;    exit(1);  }  fwrite(Comb1Segment, sizeof(unsigned char), Height*Width, file);  fclose(file);  */    // comb2  int Height = 512;  int Width = 512;  // Read Image into image data matrix  if (!(file=fopen("./HW3 Images/P1/Comb_2.raw","rb"))) {    cout << "Cannot open file: " << "./HW3 Images/P1/Comb_2.raw" << endl;    exit(1);  }  fread(tempImage, sizeof(unsigned char), Height*Width, file);  fclose(file);  int extraWin = (int)winSize/2;  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      Comb2[row+extraWin][col+extraWin] = (int)tempImage[row][col];    }  }      // pad elements to edges  // rows  for (int i=0; i<extraWin; i++){    for(int col=0; col<Width; col++){      Comb2[i][col+extraWin] = Comb2[extraWin*2-1-i][col+extraWin];    }  }  for (int i=Height+extraWin; i<Height+extraWin*2; i++){    for(int col=0; col<Width; col++){      Comb2[i][col+extraWin] = Comb2[-i+Height+extraWin+Height+extraWin-1][col+extraWin];    }  }        // cols  for (int j=0; j<extraWin; j++){    for (int row=0; row<Height; row++){      Comb2[row+extraWin][j] = Comb2[row+extraWin][-j+extraWin*2-1];    }  }  for (int j=Width+extraWin; j<Width+extraWin*2; j++){    for (int row=0; row<Height; row++){      Comb2[row+extraWin][j] = Comb2[row+extraWin][-j+Width+extraWin+Width+extraWin-1];    }  }  // corners  for (int row=0; row<extraWin; row++){    for (int col=0; col<extraWin; col++){      Comb2[row][col] = Comb2[row+extraWin][col+extraWin];    }  }    for (int row=0; row<extraWin; row++){    for (int col=Width+extraWin; col<Width+2*extraWin; col++){      Comb2[row][col] = Comb2[row][col-extraWin];    }  }    for (int row=Height+extraWin; row<Height+2*extraWin; row++){    for (int col=Width+extraWin; col<Width+2*extraWin; col++){      Comb2[row][col] = Comb2[row-extraWin][col-extraWin];    }  }  for (int row=Height+extraWin; row<Height+2*extraWin; row++){    for (int col=0; col<extraWin; col++){      Comb2[row][col] = Comb2[row-extraWin][col];    }  }      double*** EnergyMap;  EnergyMap = getEnergyMap(Comb2, extraWin, Height, Width);  // create data points matrix  double** eVec25 = new double*[Height*Width];  for (int row=0; row<Height*Width; row++){    eVec25[row] = new double[25];  }  int counter=0;  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      for (int featDim=0; featDim<25; featDim++){	eVec25[counter][featDim] = EnergyMap[row][col][featDim];      }      counter++;    }  }  // normalize the values with LL filter values  double divVal = 0;  for (int row=0; row<Height*Width; row++){    divVal += eVec25[row][0];  }  divVal /= (Height*Width);  for (int row=0; row<Height*Width; row++){    for (int col=0; col<25; col++){      eVec25[row][col] /= divVal;    }  }  // K-means  // 25-D vectors  int* class_25D = k_means(eVec25, Height*Width, 25, 6, 0.0001, 0);  // output image  int grayLevels[6] = {0, 51, 102, 153, 204, 255};  unsigned char Comb2Segment[Height][Width];  counter=0;  for (int row=0; row<Height; row++){    for (int col=0; col<Width; col++){      Comb2Segment[row][col] = (unsigned char)grayLevels[class_25D[counter]];      counter++;    }  }  if (!(file=fopen("Comb2Segment.raw","wb"))) {    cout << "Cannot open file: " << "Comb2Segment.raw" << endl;    exit(1);  }  fwrite(Comb2Segment, sizeof(unsigned char), Height*Width, file);  fclose(file);  return 0;}